{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { getPathFromUrl } from '../utils/formatting';\n\n/**\n * Service for handling replay functionality\n */\nconst replayService = {\n  /**\n   * Extract steps from an OpenAPI specification\n   * @param {Object} openApiSpec - OpenAPI 3.0 specification\n   * @returns {Array} - Array of step objects\n   */\n  extractStepsFromOpenAPI(openApiSpec) {\n    const steps = [];\n\n    // Vérifier s'il s'agit d'un fichier exporté qui contient des requêtes brutes\n    if (openApiSpec.rawRequests && Array.isArray(openApiSpec.rawRequests)) {\n      console.log('Utilisation des requêtes brutes préservées dans le fichier exporté:', openApiSpec.rawRequests.length);\n      // Convertir directement les requêtes brutes en étapes\n      return this.convertRecordedDataToScenario(openApiSpec.rawRequests);\n    }\n\n    // Validate that it's an OpenAPI spec\n    if (!openApiSpec.openapi || !openApiSpec.paths) {\n      console.error('Invalid OpenAPI format');\n      return steps;\n    }\n\n    // Check if this is our own exported recording\n    const isArkRecording = openApiSpec['x-ark-replayr'] && (openApiSpec['x-ark-replayr'].type === 'recording' || openApiSpec['x-ark-replayr'].type === 'raw-recording');\n    console.log('Loading OpenAPI spec:', {\n      isArkRecording,\n      metadata: openApiSpec['x-ark-replayr'] || 'Not an Ark Replayr recording'\n    });\n\n    // Get server URLs from the spec (if available)\n    const serverUrls = openApiSpec.servers && openApiSpec.servers.length > 0 ? openApiSpec.servers.map(server => server.url) : [''];\n    console.log('Extracting steps from OpenAPI spec with servers:', serverUrls);\n\n    // Store operations to sort them by recorded index if available\n    const operations = [];\n\n    // Extract operations from paths\n    for (const [path, pathItem] of Object.entries(openApiSpec.paths)) {\n      for (const [method, operation] of Object.entries(pathItem)) {\n        if (method === 'parameters' || method === 'summary' || method === 'description') continue;\n\n        // Store path and method with the operation\n        operations.push({\n          path,\n          method,\n          operation,\n          // Use recorded index if available, otherwise use a high number\n          index: operation['x-recorded-index'] !== undefined ? operation['x-recorded-index'] : 9999\n        });\n      }\n    }\n\n    // Sort operations by their recorded index if this is our own recording\n    if (isArkRecording) {\n      operations.sort((a, b) => a.index - b.index);\n    }\n\n    // Process each operation\n    for (const {\n      path,\n      method,\n      operation\n    } of operations) {\n      // Get the original full URL from the x-original-url extension\n      // or fall back to reconstructing from server + path\n      const fullUrl = operation['x-original-url'] || openApiSpec['x-original-urls'] && openApiSpec['x-original-urls'][`${method.toLowerCase()}-${path}`];\n      if (fullUrl) {\n        // Use the original full URL if available\n        const step = createStepFromOperation(method, path, operation, fullUrl);\n        steps.push(step);\n      } else {\n        // If no full URL, reconstruct from server + path + query params\n        // Get the server URL (use the first one if multiple are available)\n        const serverUrl = serverUrls[0] || '';\n\n        // Construct URL with query parameters\n        let reconstructedUrl = serverUrl + path;\n        const queryParams = operation.parameters?.filter(param => param.in === 'query').map(param => `${param.name}=${encodeURIComponent(param.example || '')}`) || [];\n        if (queryParams.length > 0) {\n          reconstructedUrl += '?' + queryParams.join('&');\n        }\n        console.log(`Reconstructed URL for ${method} ${path}:`, reconstructedUrl);\n\n        // Use the reconstructed URL\n        const step = createStepFromOperation(method, path, operation, reconstructedUrl);\n        steps.push(step);\n      }\n    }\n    console.log('Extracted', steps.length, 'steps with full URLs');\n    return steps;\n\n    // Helper function to create a step from an operation\n    function createStepFromOperation(method, path, operation, url) {\n      // Extract request headers from header parameters\n      const requestHeaders = {};\n      const queryParameters = {};\n      if (operation.parameters) {\n        operation.parameters.forEach(param => {\n          if (param.in === 'header') {\n            requestHeaders[param.name] = param.example || '';\n          } else if (param.in === 'query') {\n            queryParameters[param.name] = param.example || '';\n          }\n        });\n      }\n\n      // Extract request body - amélioration pour mieux gérer les formats OpenAPI 3.0.0\n      let requestBody = null;\n\n      // Fonction utilitaire pour extraire le corps réel de toute structure complexe\n      const extractRealBody = body => {\n        if (body === null || body === undefined) {\n          return null;\n        }\n\n        // Cas OpenAPI standard avec content.application/json.example\n        if (body.content && body.content['application/json'] && body.content['application/json'].example) {\n          console.log('Found body in content.application/json.example');\n          return body.content['application/json'].example;\n        }\n\n        // Cas OpenAPI avec content.application/json.schema.example (comme dans votre exemple)\n        if (body.content && body.content['application/json'] && body.content['application/json'].schema && body.content['application/json'].schema.example) {\n          console.log('Found body in content.application/json.schema.example');\n          return body.content['application/json'].schema.example;\n        }\n\n        // Si c'est un autre type d'objet, le retourner tel quel\n        return body;\n      };\n\n      // 1. Essayer d'utiliser directement le corps brut s'il existe\n      if (operation['x-raw-body'] !== undefined) {\n        requestBody = operation['x-raw-body'];\n      }\n      // 2. Sinon, essayer d'extraire du format OpenAPI standard\n      else if (operation.requestBody) {\n        // Extraire le corps réel quelle que soit sa structure\n        requestBody = extractRealBody(operation.requestBody);\n      }\n      // 3. Dernier recours - vérifier si le corps est directement dans l'opération\n      else if (operation.body) {\n        requestBody = operation.body;\n      }\n      console.log(`Request body for ${method} ${path}:`, requestBody ? typeof requestBody : 'none');\n\n      // Determine whether this came from a recording (for better CORS handling)\n      const fromRecording = operation['x-recorded-metadata'] !== undefined || openApiSpec['x-ark-replayr']?.type === 'recording' || openApiSpec['x-ark-replayr']?.type === 'raw-recording';\n\n      // Create the step with all necessary properties\n      return {\n        name: operation.summary || operation.operationId || `${method.toUpperCase()} ${path}`,\n        description: operation.description || `Recorded ${method.toUpperCase()} request to ${url}`,\n        url: url,\n        method: method.toUpperCase(),\n        enabled: true,\n        skip: false,\n        parameters: operation.parameters || [],\n        queryParameters: queryParameters,\n        requestHeaders: requestHeaders,\n        requestBody: requestBody,\n        _originalRequestBody: operation.requestBody,\n        // Garder le corps original pour débogage\n        // Include response headers if available\n        responseHeaders: operation['x-response-headers'] || {},\n        // Include original status code if available\n        statusCode: operation['x-recorded-metadata']?.statusCode,\n        responses: operation.responses || {},\n        variableSubstitutions: operation['x-variable-substitution'] || [],\n        variableCaptures: operation['x-variable-capture'] || [],\n        originalPath: path,\n        // Mark as either imported or recorded based on metadata\n        importedFromOpenAPI: true,\n        fromRecording: fromRecording,\n        // Include original metadata\n        metadata: operation['x-recorded-metadata'] || null\n      };\n    }\n  },\n  /**\n   * Convert recorded requests data to scenario steps\n   * @param {Array} recordedRequests - Recorded request data\n   * @returns {Array} - Array of step objects\n   */\n  async convertRecordedDataToScenario(recordedData) {\n    if (!recordedData || !Array.isArray(recordedData)) {\n      console.error('Invalid recorded data format:', recordedData);\n      return [];\n    }\n    try {\n      console.log('Converting recorded data to scenario, entries:', recordedData.length);\n      // Filtrer les requêtes avec les méthodes que nous souhaitons inclure\n      const filteredRequests = recordedData.filter(request => request && request.method && ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method));\n      console.log('Filtered requests:', filteredRequests.length);\n\n      // Convertir chaque requête enregistrée en étape de scénario\n      return filteredRequests.map((request, index) => {\n        // Fonction pour extraire le corps réel d'une structure OpenAPI ou autre format complexe\n        const extractRequestBody = body => {\n          // Si null ou undefined, retourner tel quel\n          if (body === null || body === undefined) {\n            return null;\n          }\n\n          // Si c'est une structure OpenAPI typique\n          if (typeof body === 'object' && body.content && body.content['application/json']) {\n            // Cas 1: Example direct\n            if (body.content['application/json'].example) {\n              console.log('Extracted body from content.application/json.example structure');\n              return body.content['application/json'].example;\n            }\n            // Cas 2: Schema avec example\n            else if (body.content['application/json'].schema && body.content['application/json'].schema.example) {\n              console.log('Extracted body from content.application/json.schema.example structure');\n              return body.content['application/json'].schema.example;\n            }\n          }\n\n          // Cas spécifique: La requête est enveloppée dans un objet content (cas particulier pour Odoo)\n          if (typeof body === 'object' && body.content) {\n            console.log('Found potential Odoo content wrapper, attempting to extract');\n            return body.content;\n          }\n\n          // Si c'est déjà un objet simple, le retourner tel quel\n          return body;\n        };\n\n        // Extraire le corps réel de la requête\n        let requestBody = extractRequestBody(request.body);\n\n        // Extraire les paramètres de requête depuis l'URL si présents\n        const urlObj = new URL(request.url, window.location.origin);\n        const queryParams = {};\n        urlObj.searchParams.forEach((value, key) => {\n          queryParams[key] = value;\n        });\n        return {\n          id: `step-${index + 1}`,\n          name: `Étape ${index + 1}: ${request.method} ${urlObj.pathname}`,\n          url: request.url,\n          method: request.method,\n          headers: request.headers || {},\n          body: requestBody || null,\n          queryParams: Object.keys(queryParams).length > 0 ? queryParams : null,\n          variables: [],\n          enabled: true,\n          delay: 0,\n          originalRequest: request,\n          // Garder la requête originale pour référence\n          // Conserver le corps sous sa forme originale pour le débogage\n          _originalBody: request.body\n        };\n      });\n    } catch (error) {\n      console.error('Error converting recorded data to scenario:', error);\n      return [];\n    }\n  },\n  /**\n   * Start replay execution with improved error handling and retry mechanism\n   * @param {Array} steps - Steps to replay\n   * @param {Object} options - Execution options\n   * @returns {Promise} - Promise that resolves with results\n   */\n  async startReplay(steps, options) {\n    console.log('Starting replay with steps:', steps.length, 'and options:', options);\n\n    // Update skip status based on enabled property\n    const preparedSteps = steps.map(step => {\n      // Ensure the step has all necessary properties for replay\n      const preparedStep = {\n        ...step,\n        skip: !step.enabled,\n        // Make sure URL is complete - apply baseUrl if specified in options\n        url: this.applyBaseUrlIfNeeded(step.url, options.baseUrl),\n        requestHeaders: step.requestHeaders || {},\n        requestBody: step.requestBody || null,\n        variableSubstitutions: step.variableSubstitutions || [],\n        variableCaptures: step.variableCaptures || []\n      };\n\n      // Ne plus ajouter les variables globales aux captures de chaque étape\n      // Elles seront traitées séparément pour plus de clarté\n\n      // Log the URL we're about to use\n      console.log(`Prepared step: ${step.method} ${preparedStep.url}`);\n      return preparedStep;\n    });\n\n    // Si l'intervalle entre les étapes est configuré, utiliser le mode pas à pas\n    if (options.stepInterval > 0) {\n      return this.startStepByStepReplay(preparedSteps, options);\n    }\n\n    // Prepare the scenario for replay (exécution standard)\n    const replayConfig = {\n      options,\n      steps: preparedSteps\n    };\n\n    // Vérifier d'abord si le background script est actif\n    try {\n      await this.checkBackgroundScriptStatus();\n    } catch (error) {\n      console.error('Background script not active:', error);\n      throw new Error(`L'extension semble ne pas être prête: ${error.message}. Rafraîchissez la page et réessayez.`);\n    }\n\n    // Send message to background script to execute replay with retry mechanism\n    return this.sendMessageWithRetry({\n      action: 'replayRequests',\n      scenario: replayConfig\n    }, 3,\n    // Nombre maximum de tentatives\n    1000 // Délai entre les tentatives en ms\n    );\n  },\n  /**\n   * Execute replay step by step with an interval between steps (for CI/CD visualization)\n   * @param {Array} steps - Steps to replay\n   * @param {Object} options - Execution options including stepInterval\n   * @returns {Promise} - Promise that resolves with results\n   */\n  async startStepByStepReplay(steps, options) {\n    console.log('Starting step-by-step replay with interval:', options.stepInterval, 'ms');\n\n    // Vérifier d'abord si le background script est actif\n    try {\n      await this.checkBackgroundScriptStatus();\n    } catch (error) {\n      console.error('Background script not active:', error);\n      throw new Error(`L'extension semble ne pas être prête: ${error.message}. Rafraîchissez la page et réessayez.`);\n    }\n    const results = [];\n    let currentStepIndex = 0;\n    // Stockage central pour les variables globales capturées\n    const globalVariablesResults = {};\n\n    // Créer une promesse qui sera résolue une fois que toutes les étapes auront été exécutées\n    return new Promise((resolve, reject) => {\n      // Fonction pour exécuter une étape\n      const executeStep = async stepIndex => {\n        if (stepIndex >= steps.length) {\n          // Toutes les étapes ont été exécutées\n          console.log('Step-by-step replay completed with', results.length, 'results');\n\n          // Ajouter les variables globales capturées aux résultats\n          if (Object.keys(globalVariablesResults).length > 0) {\n            console.log('Variables globales capturées:', globalVariablesResults);\n            // Ajouter les variables globales dans les résultats pour l'affichage dans l'onglet Variables\n            results.globalVariables = globalVariablesResults;\n          }\n\n          // Notifier que l'exécution est terminée\n          if (window.dispatchEvent) {\n            window.dispatchEvent(new CustomEvent('step-execution-progress', {\n              detail: {\n                currentStepIndex: -1,\n                results: [...results],\n                status: 'completed'\n              }\n            }));\n          }\n          resolve(results);\n          return;\n        }\n        const step = steps[stepIndex];\n        console.log(`Executing step ${stepIndex + 1}/${steps.length}: ${step.method} ${step.url}`);\n\n        // Notifier du début d'exécution de cette étape (pour l'animation)\n        if (window.dispatchEvent) {\n          window.dispatchEvent(new CustomEvent('step-execution-progress', {\n            detail: {\n              currentStepIndex: stepIndex,\n              results: [...results],\n              status: 'in-progress'\n            }\n          }));\n        }\n        try {\n          // Préparer un scénario avec une seule étape\n          const singleStepConfig = {\n            options: {\n              ...options,\n              showRuntimeProgress: false\n            },\n            // Désactiver l'option pour cette exécution unique\n            steps: [step]\n          };\n\n          // Envoyer la demande d'exécution au background script\n          const stepResult = await this.sendMessageWithRetry({\n            action: 'replayRequests',\n            scenario: singleStepConfig\n          }, 3,\n          // Nombre maximum de tentatives\n          1000 // Délai entre les tentatives en ms\n          );\n\n          // Ajouter le résultat au tableau\n          if (stepResult && stepResult.length > 0) {\n            results.push(stepResult[0]);\n          }\n\n          // Notifier de la fin d'exécution de cette étape (résultat disponible)\n          if (window.dispatchEvent) {\n            window.dispatchEvent(new CustomEvent('step-execution-progress', {\n              detail: {\n                currentStepIndex: stepIndex,\n                results: [...results],\n                status: stepResult[0]?.status || 'completed'\n              }\n            }));\n          }\n\n          // Si l'option d'arrêt sur erreur est activée et que l'étape a échoué\n          if (options.stopOnError && stepResult && stepResult[0] && stepResult[0].status === 'error') {\n            console.log('Stopping execution due to error in step', stepIndex + 1);\n\n            // Notifier de l'arrêt (pour l'UI)\n            if (window.dispatchEvent) {\n              window.dispatchEvent(new CustomEvent('step-execution-progress', {\n                detail: {\n                  currentStepIndex: -1,\n                  results: [...results],\n                  status: 'stopped'\n                }\n              }));\n            }\n            resolve(results);\n            return;\n          }\n\n          // Attendre l'intervalle configuré avant d'exécuter l'étape suivante\n          console.log(`Waiting ${options.stepInterval}ms before next step...`);\n          setTimeout(() => {\n            executeStep(stepIndex + 1);\n          }, options.stepInterval);\n        } catch (error) {\n          console.error(`Error executing step ${stepIndex + 1}:`, error);\n\n          // Ajouter une entrée d'erreur au résultat\n          results.push({\n            url: step.url,\n            method: step.method,\n            status: 'error',\n            error: error.message,\n            timestamp: new Date().toISOString()\n          });\n\n          // Notifier de l'erreur (pour l'UI)\n          if (window.dispatchEvent) {\n            window.dispatchEvent(new CustomEvent('step-execution-progress', {\n              detail: {\n                currentStepIndex: stepIndex,\n                results: [...results],\n                status: 'error'\n              }\n            }));\n          }\n\n          // Si l'option d'arrêt sur erreur est activée, arrêter l'exécution\n          if (options.stopOnError) {\n            resolve(results);\n            return;\n          }\n\n          // Sinon, continuer avec l'étape suivante après l'intervalle\n          console.log(`Waiting ${options.stepInterval}ms before next step...`);\n          setTimeout(() => {\n            executeStep(stepIndex + 1);\n          }, options.stepInterval);\n        }\n      };\n\n      // Commencer l'exécution avec la première étape\n      executeStep(0);\n    });\n  },\n  /**\n   * Send a message to the background script with retry mechanism\n   * @param {Object} message - Message to send\n   * @param {Number} maxRetries - Maximum number of retries\n   * @param {Number} delay - Delay between retries in ms\n   * @returns {Promise} - Promise that resolves with response\n   */\n  sendMessageWithRetry(message, maxRetries = 3, delay = 1000) {\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const tryToSendMessage = () => {\n        attempts++;\n        console.log(`Sending message attempt ${attempts}/${maxRetries + 1}:`, message.action);\n        chrome.runtime.sendMessage(message, response => {\n          if (chrome.runtime.lastError) {\n            console.warn(`Error in attempt ${attempts}:`, chrome.runtime.lastError);\n\n            // Si nous avons encore des tentatives disponibles, réessayer\n            if (attempts <= maxRetries) {\n              console.log(`Retrying in ${delay}ms...`);\n              setTimeout(tryToSendMessage, delay);\n            } else {\n              reject(new Error(`Could not communicate with background script after ${maxRetries + 1} attempts: ${chrome.runtime.lastError.message}`));\n            }\n          } else if (response && response.status === 'Replay completed') {\n            console.log('Replay completed successfully:', response.results?.length || 0, 'results');\n            resolve(response.results);\n          } else if (response && response.error) {\n            console.error('Error during replay:', response.error);\n            reject(new Error(response.error));\n          } else if (response) {\n            console.log('Unexpected response format:', response);\n            resolve(response); // Résoudre avec la réponse même si elle n'est pas dans le format attendu\n          } else {\n            reject(new Error('No response received from background script'));\n          }\n        });\n      };\n\n      // Commencer le processus d'envoi\n      tryToSendMessage();\n    });\n  },\n  /**\n   * Check if the background script is active\n   * @returns {Promise} - Promise that resolves if the background script is active\n   */\n  checkBackgroundScriptStatus() {\n    return new Promise((resolve, reject) => {\n      chrome.runtime.sendMessage({\n        action: 'checkExtensionStatus'\n      }, response => {\n        if (chrome.runtime.lastError) {\n          reject(new Error(`Background script not responding: ${chrome.runtime.lastError.message}`));\n        } else if (response && response.status) {\n          console.log('Background script status:', response.status);\n          resolve(response);\n        } else {\n          reject(new Error('Background script responded but no status received'));\n        }\n      });\n    });\n  },\n  /**\n   * Clear replay results\n   * @returns {Promise} - Promise that resolves when data is cleared\n   */\n  clearResults() {\n    return new Promise((resolve, reject) => {\n      chrome.storage.local.remove(['replayProgress', 'replayProgressTimestamp'], () => {\n        if (chrome.runtime.lastError) {\n          reject(chrome.runtime.lastError);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n  /**\n   * Clear all replay data\n   * @returns {Promise} - Promise that resolves when data is cleared\n   */\n  clearAllReplayData() {\n    return new Promise((resolve, reject) => {\n      chrome.storage.local.remove(['latestRecordedData', 'replayWindowData', 'replayWindowDataCount', 'autoLoadLatestRecording', 'replayProgress', 'dataTimestamp'], () => {\n        if (chrome.runtime.lastError) {\n          reject(chrome.runtime.lastError);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n  /**\n   * Export replay results as JSON file\n   * @param {Object} scenarioInfo - Information about the scenario\n   * @param {Array} results - Results of the replay\n   */\n  exportReplayResults(scenarioInfo, results) {\n    const resultData = {\n      timestamp: new Date().toISOString(),\n      scenario: scenarioInfo?.title || 'Recorded Requests Replay',\n      description: scenarioInfo?.description || 'Replay of recorded network requests',\n      results,\n      summary: {\n        totalSteps: results.length,\n        successCount: results.filter(r => r.status === 'success').length,\n        errorCount: results.filter(r => r.status === 'error').length,\n        skippedCount: results.filter(r => r.status === 'skipped').length\n      }\n    };\n    const blob = new Blob([JSON.stringify(resultData, null, 2)], {\n      type: 'application/json'\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `replay-results-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;\n\n    // Cleanup approach to avoid memory leaks\n    a.onclick = () => {\n      setTimeout(() => {\n        URL.revokeObjectURL(url);\n      }, 150);\n    };\n    a.click();\n  },\n  /**\n   * Load data from storage\n   * @returns {Promise} - Promise that resolves with loaded data\n   */\n  loadReplayData() {\n    return new Promise((resolve, reject) => {\n      chrome.storage.local.get(['latestRecordedData', 'autoLoadLatestRecording', 'replayWindowData', 'replayWindowDataCount'], result => {\n        if (chrome.runtime.lastError) {\n          reject(chrome.runtime.lastError);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  },\n  /**\n   * Apply baseUrl to a URL if needed\n   * @param {String} originalUrl - Original URL\n   * @param {String} baseUrl - Base URL to apply (optional)\n   * @returns {String} - Modified URL with new base if baseUrl is provided\n   */\n  applyBaseUrlIfNeeded(originalUrl, baseUrl) {\n    // Si pas de baseUrl ou URL originale vide, retourner l'URL d'origine\n    if (!baseUrl || !originalUrl) {\n      return originalUrl;\n    }\n    try {\n      // Analyser l'URL originale\n      const urlObj = new URL(originalUrl);\n\n      // Analyser la baseUrl\n      let baseUrlObj;\n      try {\n        // S'assurer que la baseUrl a un protocole\n        if (!baseUrl.startsWith('http://') && !baseUrl.startsWith('https://')) {\n          baseUrlObj = new URL('http://' + baseUrl);\n        } else {\n          baseUrlObj = new URL(baseUrl);\n        }\n      } catch (e) {\n        console.warn('Invalid baseUrl format:', baseUrl, e);\n        return originalUrl;\n      }\n\n      // Construire la nouvelle URL en conservant le chemin et les paramètres\n      // mais en remplaçant le protocole, l'hôte et le port\n      const newUrl = new URL(urlObj.pathname + urlObj.search + urlObj.hash, baseUrlObj.origin);\n      console.log(`Applied baseUrl: ${originalUrl} → ${newUrl.href}`);\n      return newUrl.href;\n    } catch (e) {\n      console.warn('Error applying baseUrl:', e);\n      return originalUrl;\n    }\n  },\n  /**\n   * Extraire la base URL commune à partir d'un ensemble d'étapes\n   * @param {Array} steps - Étapes contenant des URLs\n   * @returns {String} - Base URL commune ou chaîne vide si aucune base commune\n   */\n  extractCommonBaseUrl(steps) {\n    if (!steps || steps.length === 0) {\n      console.warn('Aucune étape fournie pour l\\'extraction de la base URL');\n      return '';\n    }\n    try {\n      console.log('Extraction de la base URL commune à partir de', steps.length, 'étapes');\n\n      // Vérifier si les étapes ont des URLs valides\n      const stepsWithUrls = steps.filter(step => step && step.url && typeof step.url === 'string');\n      if (stepsWithUrls.length === 0) {\n        console.warn('Aucune étape avec URL valide trouvée');\n        return '';\n      }\n      console.log('Nombre d\\'étapes avec URLs valides:', stepsWithUrls.length);\n\n      // Collecter toutes les origines (protocol + hostname + port)\n      const origins = stepsWithUrls.map(step => {\n        try {\n          // Vérifier si l'URL a un protocole, sinon ajouter http:// temporairement\n          let url = step.url;\n          if (!url.match(/^https?:\\/\\//i)) {\n            url = 'http://' + url;\n          }\n          const urlObj = new URL(url);\n          return urlObj.origin;\n        } catch (e) {\n          console.warn('Erreur lors de l\\'analyse de l\\'URL:', step.url, e);\n          return null;\n        }\n      }).filter(origin => origin !== null);\n      console.log('Origines extraites:', origins);\n\n      // Si aucune origine valide trouvée\n      if (origins.length === 0) {\n        console.warn('Aucune origine valide extraite des URLs');\n        return '';\n      }\n\n      // Trouver l'origine la plus fréquente\n      const originCounts = {};\n      let maxCount = 0;\n      let mostCommonOrigin = '';\n      origins.forEach(origin => {\n        originCounts[origin] = (originCounts[origin] || 0) + 1;\n        if (originCounts[origin] > maxCount) {\n          maxCount = originCounts[origin];\n          mostCommonOrigin = origin;\n        }\n      });\n\n      // Si l'origine la plus fréquente est présente dans moins de 50% des URLs, c'est peut-être pas une vraie base commune\n      const percentage = maxCount / origins.length * 100;\n      if (percentage < 50) {\n        console.warn(`L'origine la plus fréquente (${mostCommonOrigin}) n'est présente que dans ${percentage.toFixed(1)}% des URLs.`);\n      }\n      console.log(`Base URL commune extraite: ${mostCommonOrigin} (présente dans ${maxCount}/${origins.length} URLs, ${percentage.toFixed(1)}%)`);\n      return mostCommonOrigin;\n    } catch (e) {\n      console.error('Erreur lors de l\\'extraction de la base URL commune:', e);\n      return '';\n    }\n  },\n  /**\n   * Helper function to get the source of capture based on the response and source type\n   * @param {Object} response - The response object\n   * @param {String} sourceType - The source type (body, headers, url)\n   * @returns {String} - The source content for capture\n   */\n  getCaptureSource(response, sourceType) {\n    switch (sourceType) {\n      case 'body':\n        return response.body;\n      case 'headers':\n        return JSON.stringify(response.headers);\n      case 'url':\n        return response.url;\n      default:\n        console.warn(`Unknown capture source type: ${sourceType}`);\n        return null;\n    }\n  }\n};\nexport default replayService;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}