{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nexport default {\n  name: 'ReplayTab',\n  data() {\n    return {\n      scenario: null,\n      scenarioSteps: [],\n      expandedStep: null,\n      expandedResult: null,\n      isReplaying: false,\n      replayResults: [],\n      executionOptions: {\n        stopOnError: true\n      },\n      recordedRequestsData: null,\n      autoLoadedData: false\n    };\n  },\n  mounted() {\n    console.log('ReplayTab mounted, checking for data...');\n\n    // Add diagnostic output to help troubleshoot\n    this.dumpStorageContents();\n\n    // More robust data loading with multiple sources and fallbacks\n    chrome.storage.local.get(['latestRecordedData', 'autoLoadLatestRecording', 'replayWindowData', 'replayWindowDataCount'], result => {\n      console.log('Storage data check:', {\n        autoLoad: result.autoLoadLatestRecording,\n        latestRecordedCount: result.latestRecordedData?.length || 0,\n        replayWindowCount: result.replayWindowData?.length || 0,\n        countMetadata: result.replayWindowDataCount || 0\n      });\n\n      // Check URL parameters for state data (emergency fallback)\n      const urlParams = new URLSearchParams(window.location.search);\n      const stateParam = urlParams.get('state');\n      if (stateParam) {\n        try {\n          const state = JSON.parse(decodeURIComponent(stateParam));\n          console.log('Found state param in URL:', state);\n          if (state.directData) {\n            // This is just diagnostic info - actual data still comes from storage\n            console.log('URL indicates direct data transfer was attempted');\n          }\n        } catch (e) {\n          console.error('Error parsing state param:', e);\n        }\n      }\n\n      // First try to load data from replayWindowData (passed directly)\n      if (result.replayWindowData && result.replayWindowData.length > 0) {\n        console.log('Loading data from replayWindowData:', result.replayWindowData.length, 'requests');\n        this.recordedRequestsData = result.replayWindowData;\n        this.autoLoadedData = true;\n        this.convertRecordedDataToScenario();\n        return;\n      }\n\n      // Then try loading from latestRecordedData\n      if (result.latestRecordedData && result.latestRecordedData.length > 0) {\n        console.log('Loading data from latestRecordedData:', result.latestRecordedData.length, 'requests');\n        this.recordedRequestsData = result.latestRecordedData;\n        this.autoLoadedData = true;\n        this.convertRecordedDataToScenario();\n\n        // Reset the auto-load flag to prevent reloading on refresh only if specifically set\n        if (result.autoLoadLatestRecording) {\n          chrome.storage.local.set({\n            autoLoadLatestRecording: false\n          });\n        }\n      } else {\n        console.log('No data to auto-load');\n        // Show a message to the user\n        this.showNoDataMessage();\n      }\n    });\n  },\n  methods: {\n    loadScenarioFile(event) {\n      const file = event.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = e => {\n        try {\n          const data = JSON.parse(e.target.result);\n          this.processScenario(data);\n        } catch (error) {\n          alert('Error parsing file: ' + error.message);\n        }\n      };\n      reader.readAsText(file);\n    },\n    // Update the processScenario method to be more flexible\n    processScenario(data) {\n      // Try to handle different file formats\n      try {\n        // Check if it's an OpenAPI spec\n        if (data.openapi && data.paths) {\n          this.scenario = data;\n          this.scenarioSteps = this.extractStepsFromOpenAPI(data);\n          return;\n        }\n\n        // Check if it's our raw export format\n        if (data.requests && Array.isArray(data.requests)) {\n          console.log('Detected raw export format with requests array');\n          this.recordedRequestsData = data.requests;\n          this.autoLoadedData = true;\n          this.convertRecordedDataToScenario();\n          return;\n        }\n\n        // Check if it's an array of requests directly\n        if (Array.isArray(data) && data.length > 0 && data[0].url) {\n          console.log('Detected array of requests');\n          this.recordedRequestsData = data;\n          this.autoLoadedData = true;\n          this.convertRecordedDataToScenario();\n          return;\n        }\n\n        // If we got here, we couldn't handle the format\n        alert('Unrecognized file format. Please upload an OpenAPI 3.0 file or a recorded requests export file.');\n      } catch (error) {\n        console.error('Error processing scenario:', error);\n        alert('Error processing file: ' + error.message);\n      }\n    },\n    // Update extractStepsFromOpenAPI to better handle URL resolution\n    extractStepsFromOpenAPI(openApiSpec) {\n      const steps = [];\n\n      // Extract steps from paths\n      for (const [path, pathItem] of Object.entries(openApiSpec.paths)) {\n        for (const [method, operation] of Object.entries(pathItem)) {\n          if (method === 'parameters' || method === 'summary' || method === 'description') continue;\n\n          // Get the original full URL if available - important for replay\n          const fullUrl = operation['x-original-url'] || '';\n          const step = {\n            name: operation.summary || operation.operationId || `${method.toUpperCase()} ${path}`,\n            description: operation.description,\n            url: fullUrl || path,\n            // Use full URL if available\n            method: method.toUpperCase(),\n            skip: false,\n            enabled: true,\n            parameters: operation.parameters,\n            requestBody: operation.requestBody,\n            responses: operation.responses,\n            originalPath: path,\n            // Store original path for reference\n            'x-original-url': fullUrl,\n            // Store original URL for reference\n            variableSubstitutions: [],\n            variableCaptures: []\n          };\n\n          // Extract variable substitutions from x-variable-substitution extension\n          if (operation['x-variable-substitution']) {\n            step.variableSubstitutions = operation['x-variable-substitution'];\n          }\n\n          // Extract variable captures from x-variable-capture extension\n          if (operation['x-variable-capture']) {\n            step.variableCaptures = operation['x-variable-capture'];\n          }\n          steps.push(step);\n        }\n      }\n      return steps;\n    },\n    toggleStepDetails(index) {\n      this.expandedStep = this.expandedStep === index ? null : index;\n    },\n    toggleResultDetails(index) {\n      this.expandedResult = this.expandedResult === index ? null : index;\n    },\n    convertRecordedDataToScenario() {\n      if (!this.recordedRequestsData || !this.recordedRequestsData.length) {\n        console.warn('No recorded data to convert to scenario');\n        return;\n      }\n      console.log('Converting', this.recordedRequestsData.length, 'recorded requests to scenario steps');\n\n      // Convert recorded data to scenario steps with validation\n      this.scenarioSteps = this.recordedRequestsData.map((request, index) => {\n        // Ensure the URL is valid\n        let path = '(unknown path)';\n        try {\n          const url = request.url || '';\n          path = this.getPathFromUrl(url);\n        } catch (e) {\n          console.warn('Error parsing URL:', e);\n        }\n        return {\n          name: `Request ${index + 1}: ${request.method || 'GET'} ${path}`,\n          url: request.url || '',\n          method: request.method || 'GET',\n          enabled: true,\n          skip: false,\n          requestHeaders: request.requestHeaders || {},\n          requestBody: request.requestBody || null,\n          responseHeaders: request.responseHeaders || {},\n          variableSubstitutions: [],\n          variableCaptures: request.variableCapture || []\n        };\n      });\n      console.log('Converted to', this.scenarioSteps.length, 'scenario steps');\n    },\n    getPathFromUrl(url) {\n      try {\n        const urlObj = new URL(url);\n        return urlObj.pathname;\n      } catch (e) {\n        return url;\n      }\n    },\n    toggleAllSteps(enabled) {\n      this.scenarioSteps.forEach(step => {\n        step.skip = !enabled;\n        step.enabled = enabled;\n      });\n    },\n    // Modify startReplay to include server and URL mapping information\n    startReplay() {\n      // First clear any previous results\n      this.clearResults();\n      this.isReplaying = true;\n      this.replayResults = [];\n\n      // Update skip status based on enabled property\n      this.scenarioSteps.forEach(step => {\n        step.skip = !step.enabled;\n      });\n\n      // Prepare the scenario for replay with enhanced URL context\n      const replayConfig = {\n        options: this.executionOptions,\n        servers: this.scenario?.servers || [],\n        'x-original-urls': this.scenario?.['x-original-urls'] || {},\n        steps: this.scenarioSteps.map(step => ({\n          ...step,\n          // Include both path and URL information for better resolution\n          name: step.name,\n          method: step.method,\n          url: step.url,\n          originalPath: step.originalPath,\n          'x-original-url': step['x-original-url'],\n          skip: step.skip,\n          parameters: step.parameters,\n          requestBody: step.requestBody,\n          variableSubstitutions: step.variableSubstitutions,\n          variableCaptures: step.variableCaptures\n        }))\n      };\n\n      // Send message to background script to execute replay\n      chrome.runtime.sendMessage({\n        action: 'replayRequests',\n        scenario: replayConfig\n      }, response => {\n        this.isReplaying = false;\n        if (response && response.status === 'Replay completed') {\n          this.replayResults = response.results;\n        } else {\n          alert('Replay failed: ' + (response?.error || 'Unknown error'));\n        }\n      });\n    },\n    clearResults() {\n      // Clear the local results array\n      this.replayResults = [];\n\n      // Also clear any stored replay progress data\n      chrome.storage.local.remove(['replayProgress', 'replayProgressTimestamp'], () => {\n        console.log('Previous replay results cleared');\n      });\n    },\n    exportReplayResults() {\n      const resultData = {\n        timestamp: new Date().toISOString(),\n        scenario: this.scenario ? this.scenario.info.title : 'Recorded Requests Replay',\n        description: this.scenario ? this.scenario.info.description : 'Replay of recorded network requests',\n        executionOptions: this.executionOptions,\n        results: this.replayResults,\n        summary: {\n          totalSteps: this.replayResults.length,\n          successCount: this.replayResults.filter(r => r.status === 'success').length,\n          errorCount: this.replayResults.filter(r => r.status === 'error').length,\n          skippedCount: this.replayResults.filter(r => r.status === 'skipped').length\n        }\n      };\n      const blob = new Blob([JSON.stringify(resultData, null, 2)], {\n        type: 'application/json'\n      });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `replay-results-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;\n\n      // Cleanup approach to avoid memory leaks\n      a.onclick = () => {\n        setTimeout(() => {\n          URL.revokeObjectURL(url);\n        }, 150);\n      };\n      a.click();\n    },\n    generatePdfReport() {\n      try {\n        // Import jsPDF dynamically if not already loaded\n        import('jspdf').then(({\n          jsPDF\n        }) => {\n          import('jspdf-autotable').then(() => {\n            const doc = new jsPDF();\n\n            // Add title\n            doc.setFontSize(20);\n            doc.setTextColor(0, 51, 102);\n            doc.text('Network Request Replay Results', 14, 20);\n\n            // Add timestamp\n            doc.setFontSize(10);\n            doc.setTextColor(100, 100, 100);\n            doc.text(`Generated: ${new Date().toLocaleString()}`, 14, 30);\n\n            // Add scenario info\n            doc.setFontSize(12);\n            doc.setTextColor(0, 0, 0);\n            doc.text(`Scenario: ${this.scenario ? this.scenario.info.title : 'Recorded Requests Replay'}`, 14, 40);\n            if (this.scenario && this.scenario.info.description) {\n              doc.setFontSize(10);\n              doc.text(`Description: ${this.scenario.info.description}`, 14, 47);\n            }\n\n            // Add summary section\n            doc.setFontSize(14);\n            doc.setTextColor(0, 51, 102);\n            doc.text('Execution Summary', 14, 60);\n            const successCount = this.replayResults.filter(r => r.status === 'success').length;\n            const errorCount = this.replayResults.filter(r => r.status === 'error').length;\n            const skippedCount = this.replayResults.filter(r => r.status === 'skipped').length;\n\n            // Summary table\n            doc.autoTable({\n              startY: 65,\n              head: [['Metric', 'Value']],\n              body: [['Total Steps', this.replayResults.length.toString()], ['Successful', successCount.toString()], ['Failed', errorCount.toString()], ['Skipped', skippedCount.toString()], ['Success Rate', `${this.replayResults.length ? Math.round(successCount / this.replayResults.length * 100) : 0}%`]],\n              theme: 'grid',\n              headStyles: {\n                fillColor: [0, 51, 102],\n                textColor: [255, 255, 255]\n              },\n              styles: {\n                overflow: 'linebreak'\n              }\n            });\n\n            // Add results section\n            let yPos = doc.autoTable.previous.finalY + 15;\n            doc.setFontSize(14);\n            doc.setTextColor(0, 51, 102);\n            doc.text('Detailed Results', 14, yPos);\n\n            // Results table\n            const resultRows = this.replayResults.map((result, index) => {\n              return [(index + 1).toString(), result.step, result.status.toUpperCase(), result.status === 'error' ? result.error || 'Error occurred' : 'OK'];\n            });\n\n            // If multiple pages needed, ensure good layout\n            doc.autoTable({\n              startY: yPos + 5,\n              head: [['#', 'Step', 'Status', 'Details']],\n              body: resultRows,\n              theme: 'grid',\n              headStyles: {\n                fillColor: [0, 51, 102],\n                textColor: [255, 255, 255]\n              },\n              styles: {\n                overflow: 'linebreak'\n              },\n              columnStyles: {\n                0: {\n                  cellWidth: 10\n                },\n                2: {\n                  cellWidth: 25\n                }\n              },\n              didDrawCell: data => {\n                // Add color to the status cell based on status\n                if (data.column.index === 2 && data.section === 'body') {\n                  const status = this.replayResults[data.row.index].status;\n                  if (status === 'success') {\n                    doc.setFillColor(0, 128, 0, 0.1); // light green\n                    doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'F');\n                  } else if (status === 'error') {\n                    doc.setFillColor(255, 0, 0, 0.1); // light red\n                    doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'F');\n                  } else if (status === 'skipped') {\n                    doc.setFillColor(255, 165, 0, 0.1); // light orange\n                    doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'F');\n                  }\n                }\n              }\n            });\n\n            // Add footer with page numbers\n            const pageCount = doc.internal.getNumberOfPages();\n            for (let i = 1; i <= pageCount; i++) {\n              doc.setPage(i);\n              doc.setFontSize(10);\n              doc.setTextColor(100, 100, 100);\n              doc.text(`Page ${i} of ${pageCount}`, doc.internal.pageSize.getWidth() / 2, doc.internal.pageSize.getHeight() - 10, {\n                align: 'center'\n              });\n            }\n\n            // Save the PDF\n            doc.save(`replay-report-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.pdf`);\n          });\n        }).catch(error => {\n          console.error('Error loading PDF libraries:', error);\n          alert('Could not generate PDF. Please check console for errors.');\n        });\n      } catch (error) {\n        console.error('Error generating PDF report:', error);\n        alert('Error generating PDF report: ' + error.message);\n      }\n    },\n    clearAllReplayData() {\n      if (confirm('Are you sure you want to clear all replay data? This action cannot be undone.')) {\n        // Clear all replay-related data from storage\n        chrome.storage.local.remove(['latestRecordedData', 'replayWindowData', 'replayWindowDataCount', 'autoLoadLatestRecording', 'replayProgress', 'dataTimestamp'], () => {\n          // Reset component data\n          this.recordedRequestsData = null;\n          this.scenario = null;\n          this.scenarioSteps = [];\n          this.replayResults = [];\n          this.autoLoadedData = false;\n\n          // Show confirmation to user\n          alert('All replay data has been cleared.');\n        });\n      }\n    },\n    dumpStorageContents() {\n      chrome.storage.local.get(null, items => {\n        console.log('All storage contents:', Object.keys(items));\n\n        // Check specific data structures\n        if (items.latestRecordedData) {\n          console.log('latestRecordedData info:', {\n            count: items.latestRecordedData.length,\n            firstItem: items.latestRecordedData[0] ? {\n              url: items.latestRecordedData[0].url,\n              method: items.latestRecordedData[0].method\n            } : null\n          });\n        }\n        if (items.replayWindowData) {\n          console.log('replayWindowData info:', {\n            count: items.replayWindowData.length,\n            firstItem: items.replayWindowData[0] ? {\n              url: items.replayWindowData[0].url,\n              method: items.replayWindowData[0].method\n            } : null\n          });\n        }\n      });\n    },\n    showNoDataMessage() {\n      // Add UI indication that no data was found\n      this.executionStatus = 'No recorded data found to replay';\n    },\n    // Add the missing formatJson method\n    formatJson(data) {\n      if (!data) return 'No data available';\n      try {\n        if (typeof data === 'object') {\n          return JSON.stringify(data, null, 2);\n        } else if (typeof data === 'string') {\n          // Try to parse as JSON if it's a string\n          try {\n            const parsed = JSON.parse(data);\n            return JSON.stringify(parsed, null, 2);\n          } catch {\n            // If parsing fails, just return the string\n            return data;\n          }\n        }\n        return String(data);\n      } catch (e) {\n        console.error('Error formatting JSON:', e);\n        return String(data);\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}