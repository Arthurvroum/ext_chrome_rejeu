{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport RecordControls from './RecordControls.vue';\nimport VariableCaptureForm from './VariableCaptureForm.vue';\nimport recordService from '../../services/recordService';\nimport { isRestrictedUrl } from '../../utils/chromeApi';\nexport default {\n  name: 'RecordTab',\n  components: {\n    RecordControls,\n    VariableCaptureForm\n  },\n  data() {\n    return {\n      isRecording: false,\n      recordingStatus: 'Ready to record',\n      recordedRequests: [],\n      recordedCount: 0,\n      expandedRequest: null,\n      activeTab: null,\n      showReplayOption: false,\n      restrictedUrlWarning: false,\n      activeTabId: null,\n      activeTabUrl: '',\n      contentScriptReady: false,\n      isOpeningReplayTab: false // Add this flag to prevent multiple clicks\n    };\n  },\n  computed: {\n    hasRecordedData() {\n      return this.recordedRequests && this.recordedRequests.length > 0;\n    }\n  },\n  mounted() {\n    // Check if we're already recording when the popup opens\n    this.checkRecordingStatus();\n\n    // Set up polling to update request count during recording\n    this.statusInterval = setInterval(() => {\n      if (this.isRecording) {\n        this.updateRecordingStatus();\n      }\n    }, 2000);\n\n    // Check current page compatibility\n    this.checkCurrentPageCompatibility();\n  },\n  beforeUnmount() {\n    if (this.statusInterval) {\n      clearInterval(this.statusInterval);\n    }\n  },\n  methods: {\n    async checkRecordingStatus() {\n      const response = await recordService.getRecordingStatus();\n      if (response && response.isRecording) {\n        this.isRecording = true;\n        this.recordingStatus = 'Recording active...';\n        this.recordedCount = response.requestCount || 0;\n      }\n    },\n    async updateRecordingStatus() {\n      const response = await recordService.getRecordingStatus();\n      if (response) {\n        this.recordedCount = response.requestCount || 0;\n      }\n    },\n    async toggleRecording() {\n      if (this.restrictedUrlWarning) {\n        this.recordingStatus = 'Cannot record from this page type';\n        return;\n      }\n      try {\n        if (!this.isRecording) {\n          // Show immediate feedback to user\n          this.recordingStatus = 'Initializing recording...';\n\n          // Start recording\n          const response = await recordService.startRecording();\n          if (response && response.status && !response.error) {\n            this.isRecording = true;\n            this.recordingStatus = 'Recording active...';\n            this.showReplayOption = false;\n          } else {\n            this.recordingStatus = `Error: ${response.error || 'Failed to start recording'}`;\n          }\n        } else {\n          // Stop recording\n          const response = await recordService.stopRecording();\n          if (response && response.status) {\n            this.isRecording = false;\n            this.recordingStatus = 'Recording stopped';\n            this.recordedRequests = response.data || [];\n\n            // Show replay option if we have recorded data\n            if (this.recordedRequests.length > 0) {\n              this.showReplayOption = true;\n            }\n          } else {\n            this.recordingStatus = `Error: ${response.error || 'Failed to stop recording'}`;\n          }\n        }\n      } catch (error) {\n        console.error('Error toggling recording:', error);\n        this.recordingStatus = `Error: ${error.message}`;\n      }\n    },\n    async exportRecording() {\n      try {\n        // Show a dialog to choose export format\n        const exportRaw = confirm('Would you like to export ALL requests? (Click OK for all requests, Cancel for API requests only)');\n        if (exportRaw) {\n          // Export all requests as raw JSON\n          await this.exportRawData(this.recordedRequests);\n          this.recordingStatus = 'All requests exported successfully';\n        } else {\n          // Original OpenAPI export (might filter some requests)\n          const response = await sendMessageToBackground({\n            action: 'convertToOpenAPI',\n            data: this.recordedRequests\n          });\n          if (response && response.openApiSpec) {\n            // Create downloadable file\n            const blob = new Blob([JSON.stringify(response.openApiSpec, null, 2)], {\n              type: 'application/json'\n            });\n            const url = URL.createObjectURL(blob);\n\n            // Create download link\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = 'recorded-requests.json';\n            document.body.appendChild(a);\n            a.click();\n\n            // Clean up\n            document.body.removeChild(a);\n            URL.revokeObjectURL(url);\n            this.recordingStatus = 'Requests exported as OpenAPI successfully';\n          }\n        }\n      } catch (error) {\n        console.error('Error exporting recording:', error);\n        this.recordingStatus = `Export error: ${error.message}`;\n      }\n    },\n    // Helper function to export raw data without any filtering\n    async exportRawData(requests) {\n      try {\n        // Create a deep copy with a timestamp\n        const exportData = {\n          timestamp: new Date().toISOString(),\n          title: 'Raw Network Requests Export',\n          description: 'Unfiltered export of all recorded network requests',\n          count: requests.length,\n          requests: JSON.parse(JSON.stringify(requests))\n        };\n\n        // Create downloadable file\n        const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n          type: 'application/json'\n        });\n        const url = URL.createObjectURL(blob);\n\n        // Create download link\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `all-requests-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;\n        document.body.appendChild(a);\n        a.click();\n\n        // Clean up\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        return {\n          success: true\n        };\n      } catch (error) {\n        console.error('Error exporting raw data:', error);\n        throw error;\n      }\n    },\n    clearRecordings() {\n      this.recordedRequests = [];\n      this.recordingStatus = 'Data cleared';\n      this.showReplayOption = false;\n    },\n    toggleDetails(index) {\n      this.expandedRequest = this.expandedRequest === index ? null : index;\n    },\n    updateRequest(index, updatedRequest) {\n      this.recordedRequests[index] = updatedRequest;\n      // Create a new array to trigger reactivity\n      this.recordedRequests = [...this.recordedRequests];\n    },\n    async openReplayInNewTab() {\n      // Prevent multiple clicks from triggering multiple tabs\n      if (this.isOpeningReplayTab) {\n        console.log('Already opening replay tab, ignoring duplicate request');\n        return;\n      }\n      try {\n        this.isOpeningReplayTab = true;\n        this.recordingStatus = 'Opening replay tab...';\n        const response = await recordService.openReplayInNewTab(this.recordedRequests);\n        if (!response || !response.success) {\n          this.recordingStatus = 'Error opening replay tab';\n        } else {\n          this.recordingStatus = 'Replay tab opened successfully';\n        }\n\n        // Reset the flag after a delay to prevent multiple rapid clicks\n        setTimeout(() => {\n          this.isOpeningReplayTab = false;\n        }, 2000);\n      } catch (error) {\n        console.error('Error opening replay tab:', error);\n        this.recordingStatus = `Error opening replay tab: ${error.message}`;\n        this.isOpeningReplayTab = false;\n      }\n    },\n    async checkCurrentPageCompatibility() {\n      try {\n        // Get active tab info\n        const tabs = await chrome.tabs.query({\n          active: true,\n          currentWindow: true\n        });\n        if (!tabs || !tabs.length) return;\n        const activeTab = tabs[0];\n        this.activeTabId = activeTab.id;\n        this.activeTabUrl = activeTab.url || '';\n\n        // Check if it's a restricted URL\n        this.restrictedUrlWarning = isRestrictedUrl(this.activeTabUrl);\n        if (this.restrictedUrlWarning) {\n          this.recordingStatus = 'Recording not available on this page';\n        }\n      } catch (error) {\n        console.error('Error checking page compatibility:', error);\n      }\n    },\n    getMethodColor(method) {\n      const colors = {\n        GET: 'primary',\n        POST: 'success',\n        PUT: 'warning',\n        DELETE: 'error',\n        PATCH: 'info'\n      };\n      return colors[method] || 'grey';\n    },\n    getStatusColor(status) {\n      const statusNum = parseInt(status);\n      if (statusNum >= 200 && statusNum < 300) return 'success';\n      if (statusNum >= 300 && statusNum < 400) return 'info';\n      if (statusNum >= 400 && statusNum < 500) return 'warning';\n      if (statusNum >= 500) return 'error';\n      return 'grey';\n    },\n    addVariableCapture(captureConfig) {\n      const index = this.expandedRequest;\n      if (index === null) return;\n      if (!this.recordedRequests[index].variableCapture) {\n        this.recordedRequests[index].variableCapture = [];\n      }\n      this.recordedRequests[index].variableCapture.push(captureConfig);\n      this.recordedRequests = [...this.recordedRequests];\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}