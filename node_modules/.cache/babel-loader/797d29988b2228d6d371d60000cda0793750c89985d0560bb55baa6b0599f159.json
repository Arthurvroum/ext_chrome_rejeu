{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport RecordControls from './RecordControls.vue';\nimport VariableCaptureForm from './VariableCaptureForm.vue';\nimport recordService from '../../services/recordService';\nimport { isRestrictedUrl } from '../../utils/chromeApi';\nexport default {\n  name: 'RecordTab',\n  components: {\n    RecordControls,\n    VariableCaptureForm\n  },\n  data() {\n    return {\n      isRecording: false,\n      recordingStatus: 'Ready to record',\n      recordedRequests: [],\n      recordedCount: 0,\n      expandedRequest: null,\n      activeTab: null,\n      restrictedUrlWarning: false,\n      activeTabId: null,\n      activeTabUrl: '',\n      contentScriptReady: false,\n      isOpeningReplayTab: false // Add this flag to prevent multiple clicks\n    };\n  },\n  computed: {\n    hasRecordedData() {\n      return this.recordedRequests && this.recordedRequests.length > 0;\n    }\n  },\n  mounted() {\n    // Check if we're already recording when the popup opens\n    this.checkRecordingStatus();\n\n    // Set up polling to update request count during recording\n    this.statusInterval = setInterval(() => {\n      if (this.isRecording) {\n        this.updateRecordingStatus();\n      }\n    }, 2000);\n\n    // Check current page compatibility\n    this.checkCurrentPageCompatibility();\n  },\n  beforeUnmount() {\n    if (this.statusInterval) {\n      clearInterval(this.statusInterval);\n    }\n  },\n  methods: {\n    async checkRecordingStatus() {\n      const response = await recordService.getRecordingStatus();\n      if (response && response.isRecording) {\n        this.isRecording = true;\n        this.recordingStatus = 'Recording active...';\n        this.recordedCount = response.requestCount || 0;\n      }\n    },\n    async updateRecordingStatus() {\n      const response = await recordService.getRecordingStatus();\n      if (response) {\n        this.recordedCount = response.requestCount || 0;\n      }\n    },\n    async toggleRecording() {\n      if (this.restrictedUrlWarning) {\n        this.recordingStatus = 'Cannot record from this page type';\n        return;\n      }\n      try {\n        if (!this.isRecording) {\n          // Show immediate feedback to user\n          this.recordingStatus = 'Initializing recording...';\n\n          // Start recording\n          const response = await recordService.startRecording();\n          if (response && response.status && !response.error) {\n            this.isRecording = true;\n            this.recordingStatus = 'Recording active...';\n          } else {\n            this.recordingStatus = `Error: ${response.error || 'Failed to start recording'}`;\n          }\n        } else {\n          // Stop recording\n          this.recordingStatus = 'Stopping recording...';\n          const response = await recordService.stopRecording();\n          if (response) {\n            // Set the recordedRequests to the data array, even if empty\n            this.recordedRequests = response.data || [];\n            this.isRecording = false;\n            if (response.status === 'error') {\n              this.recordingStatus = `Error: ${response.error || 'Unknown error'}`;\n              console.error('Error stopping recording:', response.error);\n            } else if (response.status === 'warning') {\n              this.recordingStatus = `Warning: ${response.message || 'Recording stopped with warnings'}`;\n              console.warn('Warning when stopping recording:', response.message);\n            } else {\n              this.recordingStatus = 'Recording stopped';\n            }\n          } else {\n            this.isRecording = false;\n            this.recordingStatus = 'Recording stopped with issues';\n            console.error('Error stopping recording: Empty response');\n          }\n        }\n      } catch (error) {\n        this.recordingStatus = 'Error while recording';\n        console.error('Recording error:', error);\n      }\n    },\n    async exportRecording() {\n      try {\n        await recordService.exportAsOpenAPI(this.recordedRequests);\n      } catch (error) {\n        console.error('Error exporting recording:', error);\n        this.recordingStatus = `Export error: ${error.message}`;\n      }\n    },\n    clearRecordings() {\n      this.recordedRequests = [];\n      this.recordingStatus = 'Data cleared';\n    },\n    toggleDetails(index) {\n      this.expandedRequest = this.expandedRequest === index ? null : index;\n    },\n    updateRequest(index, updatedRequest) {\n      this.recordedRequests[index] = updatedRequest;\n      // Create a new array to trigger reactivity\n      this.recordedRequests = [...this.recordedRequests];\n    },\n    async openReplayInNewTab() {\n      if (this.isOpeningReplayTab) return; // Prevent multiple clicks\n\n      this.isOpeningReplayTab = true;\n      try {\n        // Even if there are no requests, open the replay tab anyway\n        // The user can then import a file if needed\n        const response = await recordService.openReplayInNewTab(this.recordedRequests || []);\n        if (!response || !response.success) {\n          console.error('Error opening replay tab:', response?.error);\n          this.recordingStatus = `Error: ${response?.error || 'Failed to open replay tab'}`;\n        }\n      } catch (error) {\n        console.error('Error opening replay tab:', error);\n        this.recordingStatus = `Error opening replay tab: ${error.message || 'Unknown error'}`;\n      } finally {\n        this.isOpeningReplayTab = false;\n      }\n    },\n    async checkCurrentPageCompatibility() {\n      try {\n        // Get active tab info\n        const tabs = await chrome.tabs.query({\n          active: true,\n          currentWindow: true\n        });\n        if (!tabs || !tabs.length) return;\n        const activeTab = tabs[0];\n        this.activeTabId = activeTab.id;\n        this.activeTabUrl = activeTab.url || '';\n\n        // Check if it's a restricted URL\n        this.restrictedUrlWarning = isRestrictedUrl(this.activeTabUrl);\n        if (this.restrictedUrlWarning) {\n          this.recordingStatus = 'Recording not available on this page';\n        }\n      } catch (error) {\n        console.error('Error checking page compatibility:', error);\n      }\n    },\n    getMethodColor(method) {\n      const colors = {\n        GET: 'primary',\n        POST: 'success',\n        PUT: 'warning',\n        DELETE: 'error',\n        PATCH: 'info'\n      };\n      return colors[method] || 'grey';\n    },\n    getStatusColor(status) {\n      const statusNum = parseInt(status);\n      if (statusNum >= 200 && statusNum < 300) return 'success';\n      if (statusNum >= 300 && statusNum < 400) return 'info';\n      if (statusNum >= 400 && statusNum < 500) return 'warning';\n      if (statusNum >= 500) return 'error';\n      return 'grey';\n    },\n    addVariableCapture(captureConfig) {\n      const index = this.expandedRequest;\n      if (index === null) return;\n      if (!this.recordedRequests[index].variableCapture) {\n        this.recordedRequests[index].variableCapture = [];\n      }\n      this.recordedRequests[index].variableCapture.push(captureConfig);\n      this.recordedRequests = [...this.recordedRequests];\n    },\n    showError(message) {\n      this.recordingStatus = message;\n      console.error(message);\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}