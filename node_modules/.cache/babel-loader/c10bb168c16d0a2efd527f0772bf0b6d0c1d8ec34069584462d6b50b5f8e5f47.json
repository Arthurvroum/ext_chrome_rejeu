{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n// Import components\nimport ReplayHeader from './replay/ReplayHeader.vue';\nimport ExecutionOptions from './replay/ExecutionOptions.vue';\nimport StepsList from './replay/StepsList.vue';\nexport default {\n  name: 'ReplayTab',\n  components: {\n    ReplayHeader,\n    ExecutionOptions,\n    StepsList\n  },\n  data() {\n    return {\n      scenario: null,\n      scenarioSteps: [],\n      expandedStep: null,\n      expandedResult: null,\n      isReplaying: false,\n      replayResults: [],\n      executionOptions: {\n        stopOnError: true,\n        stepInterval: 1000,\n        // Intervalle de 1 seconde par défaut\n        showRuntimeProgress: true // Afficher la progression en temps réel par défaut\n      },\n      recordedRequestsData: null,\n      autoLoadedData: false,\n      executionStatus: 'Ready to start',\n      currentStepIndex: -1,\n      // Index de l'étape en cours d'exécution\n      activeTab: 'replay' // Onglet actif par défaut\n    };\n  },\n  computed: {\n    executionStatusClass() {\n      if (this.executionStatus.includes('Error') || this.executionStatus.includes('Failed')) {\n        return 'error';\n      } else if (this.executionStatus.includes('Complete')) {\n        return 'success';\n      } else if (this.executionStatus.includes('Running')) {\n        return 'in-progress';\n      }\n      return '';\n    }\n  },\n  mounted() {\n    console.log('ReplayTab mounted, checking for data...');\n\n    // Add diagnostic output to help troubleshoot\n    this.dumpStorageContents();\n\n    // More robust data loading with multiple sources and fallbacks\n    chrome.storage.local.get(['latestRecordedData', 'autoLoadLatestRecording', 'replayWindowData', 'replayWindowDataCount'], result => {\n      console.log('Storage data check:', {\n        autoLoad: result.autoLoadLatestRecording,\n        latestRecordedCount: result.latestRecordedData?.length || 0,\n        replayWindowCount: result.replayWindowData?.length || 0,\n        countMetadata: result.replayWindowDataCount || 0\n      });\n\n      // Check URL parameters for state data (emergency fallback)\n      const urlParams = new URLSearchParams(window.location.search);\n      const stateParam = urlParams.get('state');\n      if (stateParam) {\n        try {\n          const state = JSON.parse(decodeURIComponent(stateParam));\n          console.log('Found state param in URL:', state);\n          if (state.directData) {\n            // This is just diagnostic info - actual data still comes from storage\n            console.log('URL indicates direct data transfer was attempted');\n          }\n        } catch (e) {\n          console.error('Error parsing state param:', e);\n        }\n      }\n\n      // First try to load data from replayWindowData (passed directly)\n      if (result.replayWindowData && result.replayWindowData.length > 0) {\n        console.log('Loading data from replayWindowData:', result.replayWindowData.length, 'requests');\n        this.recordedRequestsData = result.replayWindowData;\n        this.autoLoadedData = true;\n        this.convertRecordedDataToScenario();\n        return;\n      }\n\n      // Then try loading from latestRecordedData\n      if (result.latestRecordedData && result.latestRecordedData.length > 0) {\n        console.log('Loading data from latestRecordedData:', result.latestRecordedData.length, 'requests');\n        this.recordedRequestsData = result.latestRecordedData;\n        this.autoLoadedData = true;\n        this.convertRecordedDataToScenario();\n\n        // Reset the auto-load flag to prevent reloading on refresh only if specifically set\n        if (result.autoLoadLatestRecording) {\n          chrome.storage.local.set({\n            autoLoadLatestRecording: false\n          });\n        }\n      } else {\n        console.log('No data to auto-load');\n        // Show a message to the user\n        this.showNoDataMessage();\n      }\n    });\n  },\n  methods: {\n    loadScenarioFile(event) {\n      let file;\n\n      // Check if event is a File object directly\n      if (event instanceof File) {\n        file = event;\n      }\n      // Check if event is a DOM event with files\n      else if (event.target && event.target.files && event.target.files[0]) {\n        file = event.target.files[0];\n      } else {\n        console.error('Invalid file input:', event);\n        this.$root.$emit('show-snackbar', {\n          text: 'Invalid file input provided',\n          color: 'error'\n        });\n        return;\n      }\n      const reader = new FileReader();\n      reader.onload = e => {\n        try {\n          const data = JSON.parse(e.target.result);\n\n          // Vérifier si c'est un fichier exporté avec des requêtes brutes\n          if (data.rawRequests && Array.isArray(data.rawRequests)) {\n            console.log('Fichier exporté avec requêtes brutes détecté:', data.rawRequests.length);\n            console.log('Structure d\\'une requête brute:', JSON.stringify(data.rawRequests[0], null, 2));\n\n            // Stocker les requêtes exactement comme elles sont, sans modification\n            this.recordedRequestsData = data.rawRequests.map(req => {\n              // Préserver la structure exacte du corps de la requête\n              // Aucune modification ou transformation n'est appliquée\n              return {\n                ...req,\n                body: req.body || req.requestBody // S'assurer que nous avons le corps sous le bon nom\n              };\n            });\n            this.autoLoadedData = true;\n            this.convertRecordedDataToScenario();\n            this.$root.$emit('show-snackbar', {\n              text: 'Fichier exporté chargé avec succès - ' + data.rawRequests.length + ' requêtes',\n              color: 'success',\n              timeout: 3000\n            });\n            return;\n          }\n\n          // Format OpenAPI traditionnel\n          this.processScenario(data);\n        } catch (error) {\n          this.$root.$emit('show-snackbar', {\n            text: 'Error parsing file: ' + error.message,\n            color: 'error'\n          });\n        }\n      };\n      reader.readAsText(file);\n    },\n    processScenario(data) {\n      // Validate that it's an OpenAPI spec\n      if (!data.openapi || !data.paths) {\n        // Vérifier s'il s'agit de notre propre format d'exportation non-OpenAPI\n        if (data.rawRequests && Array.isArray(data.rawRequests)) {\n          console.log('Fichier exporté avec format spécial RAW détecté:', data.rawRequests.length);\n\n          // Utiliser directement les rawRequests sans aucune transformation\n          this.recordedRequestsData = data.rawRequests;\n          this.autoLoadedData = true;\n          this.convertRecordedDataToScenario();\n          this.$root.$emit('show-snackbar', {\n            text: 'Fichier au format RAW chargé avec succès - ' + data.rawRequests.length + ' requêtes',\n            color: 'success',\n            timeout: 3000\n          });\n          return;\n        }\n        this.$root.$emit('show-snackbar', {\n          text: 'Format de fichier invalide. Veuillez charger un fichier OpenAPI 3.0 ou un export de Ark Replayr.',\n          color: 'error'\n        });\n        return;\n      }\n\n      // Check if this is our own exported recording\n      const isArkRecording = data['x-ark-replayr'] && data['x-ark-replayr'].type === 'recording';\n\n      // Set different flags based on the source\n      if (isArkRecording) {\n        this.$root.$emit('show-snackbar', {\n          text: 'Fichier OpenAPI avec métadonnées complètes chargé',\n          color: 'success',\n          timeout: 3000\n        });\n      } else {\n        // Pour les fichiers OpenAPI standards, on prévient que la structure sera modifiée\n        this.$root.$emit('show-snackbar', {\n          text: 'Fichier OpenAPI importé - certains détails peuvent être limités, préférez le format RAW pour les exportations',\n          color: 'info',\n          timeout: 5000\n        });\n      }\n      this.scenario = data;\n      this.scenarioSteps = this.extractStepsFromOpenAPI(data);\n\n      // Maintenant, vérifions si le fichier OpenAPI contient notre extension spéciale avec les corps bruts\n      if (data['x-ark-replayr'] && data['x-ark-replayr'].rawBodies) {\n        console.log('Extension x-ark-replayr avec corps bruts trouvée:', Object.keys(data['x-ark-replayr'].rawBodies).length);\n\n        // Restaurer les corps bruts originaux dans les étapes\n        this.scenarioSteps.forEach((step, index) => {\n          const operationId = step.originalOperationId || `op${index}`;\n          if (data['x-ark-replayr'].rawBodies[operationId]) {\n            console.log(`Restauration du corps brut pour l'opération ${operationId}`);\n            step.requestBody = data['x-ark-replayr'].rawBodies[operationId];\n            step._originalRequestBody = data['x-ark-replayr'].rawBodies[operationId];\n          }\n        });\n      }\n    },\n    extractStepsFromOpenAPI(openApiSpec) {\n      const steps = [];\n\n      // Extract steps from paths\n      for (const [path, pathItem] of Object.entries(openApiSpec.paths)) {\n        for (const [method, operation] of Object.entries(pathItem)) {\n          if (method === 'parameters' || method === 'summary' || method === 'description') continue;\n\n          // Get the original full URL from the extension property\n          const fullUrl = operation['x-original-url'] || '';\n          const step = {\n            name: operation.summary || operation.operationId,\n            description: operation.description,\n            url: fullUrl,\n            // Use the full URL instead of just the path\n            method: method.toUpperCase(),\n            skip: false,\n            parameters: operation.parameters,\n            requestBody: operation.requestBody,\n            responses: operation.responses,\n            variableSubstitutions: [],\n            variableCaptures: [],\n            // Mark as imported so we can handle it specially\n            importedFromOpenAPI: true,\n            originalPath: path\n          };\n\n          // Extract variable substitutions from x-variable-substitution extension\n          if (operation['x-variable-substitution']) {\n            step.variableSubstitutions = operation['x-variable-substitution'];\n          }\n\n          // Extract variable captures from x-variable-capture extension\n          if (operation['x-variable-capture']) {\n            step.variableCaptures = operation['x-variable-capture'];\n          }\n          steps.push(step);\n        }\n      }\n\n      // Show warning about imported requests\n      this.$nextTick(() => {\n        this.$root.$emit('show-snackbar', {\n          text: 'Imported requests may have limited functionality due to browser security restrictions.',\n          color: 'warning',\n          timeout: 8000\n        });\n      });\n      return steps;\n    },\n    updateStep(index, updatedStep) {\n      if (index >= 0 && index < this.scenarioSteps.length) {\n        this.scenarioSteps[index] = {\n          ...this.scenarioSteps[index],\n          ...updatedStep\n        };\n        // Force reactivity\n        this.scenarioSteps = [...this.scenarioSteps];\n      }\n    },\n    toggleStepDetails(index) {\n      this.expandedStep = this.expandedStep === index ? null : index;\n    },\n    toggleResultDetails(index) {\n      this.expandedResult = this.expandedResult === index ? null : index;\n    },\n    convertRecordedDataToScenario() {\n      if (!this.recordedRequestsData || !this.recordedRequestsData.length) {\n        console.warn('No recorded data to convert to scenario');\n        return;\n      }\n      console.log('Converting', this.recordedRequestsData.length, 'recorded requests to scenario steps');\n      console.log('First request sample:', JSON.stringify(this.recordedRequestsData[0]));\n\n      // Convert recorded data to scenario steps with validation\n      this.scenarioSteps = this.recordedRequestsData.map((request, index) => {\n        // Ensure the URL is valid\n        let path = '(unknown path)';\n        try {\n          const url = request.url || '';\n          path = this.getPathFromUrl(url);\n        } catch (e) {\n          console.warn('Error parsing URL:', e);\n        }\n\n        // Préserver la structure exacte du corps de la requête sans aucune modification\n        // Stocker directement la référence à l'objet original\n        let requestBody = request.requestBody || request.body;\n\n        // IMPORTANT: Log détaillé pour diagnostiquer la structure exacte\n        console.log(`Request ${index + 1} body:`, JSON.stringify(requestBody, null, 2));\n        return {\n          name: `Request ${index + 1}: ${request.method || 'GET'} ${path}`,\n          url: request.url || '',\n          method: request.method || 'GET',\n          enabled: true,\n          skip: false,\n          requestHeaders: request.requestHeaders || {},\n          // Stocker exactement le même objet sans transformation\n          requestBody: requestBody,\n          responseHeaders: request.responseHeaders || {},\n          variableSubstitutions: [],\n          variableCaptures: request.variableCapture || [],\n          // Conserver le corps original pour référence et pour les exportations\n          _originalRequestBody: requestBody,\n          // Flag indiquant que cette requête est importée depuis un fichier\n          _imported: true,\n          // Métadonnées supplémentaires pour le debugging\n          _importMetadata: {\n            timestamp: new Date().toISOString(),\n            originalFormat: typeof requestBody,\n            hasBeenTransformed: false\n          }\n        };\n      });\n      console.log('Converted to', this.scenarioSteps.length, 'scenario steps');\n      console.log('Sample converted step:', JSON.stringify(this.scenarioSteps[0], null, 2));\n    },\n    getPathFromUrl(url) {\n      try {\n        const urlObj = new URL(url);\n        return urlObj.pathname;\n      } catch (e) {\n        return url;\n      }\n    },\n    toggleAllSteps(enabled) {\n      this.scenarioSteps.forEach(step => {\n        step.skip = !enabled;\n        step.enabled = enabled;\n      });\n    },\n    startReplay() {\n      // First clear any previous results\n      this.clearResults();\n\n      // For imported OpenAPI scenarios (not our own recordings), show a warning\n      const isImportedOpenAPI = this.scenario && (!this.scenario['x-ark-replayr'] || this.scenario['x-ark-replayr'].type !== 'recording');\n      if (isImportedOpenAPI) {\n        this.$root.$emit('show-snackbar', {\n          text: 'Imported requests may have CORS limitations. For best results, record requests directly.',\n          color: 'warning',\n          timeout: 6000\n        });\n      }\n      this.isReplaying = true;\n      this.replayResults = [];\n      this.executionStatus = 'Running replay...';\n      this.currentStepIndex = -1; // Réinitialiser l'index de l'étape courante\n\n      // Update skip status based on enabled property\n      this.scenarioSteps.forEach(step => {\n        step.skip = !step.enabled;\n      });\n\n      // Importer le service replayService\n      import('../services/replayService').then(module => {\n        const replayService = module.default;\n\n        // Écouter les événements d'avancement des étapes\n        window.addEventListener('step-execution-progress', this.handleStepProgress);\n\n        // Lancer l'exécution avec le service replayService\n        replayService.startReplay(this.scenarioSteps, this.executionOptions).then(results => {\n          this.isReplaying = false;\n          this.replayResults = results;\n          this.executionStatus = 'Execution Complete';\n          this.currentStepIndex = -1; // Réinitialiser l'index de l'étape courante\n\n          // Show success message\n          this.$root.$emit('show-snackbar', {\n            text: `Replay completed: ${this.replayResults.filter(r => r.status === 'success').length} of ${this.replayResults.length} steps successful`,\n            color: 'success',\n            timeout: 4000\n          });\n        }).catch(error => {\n          this.isReplaying = false;\n          this.executionStatus = 'Execution Failed';\n          alert('Replay failed: ' + error.message);\n        }).finally(() => {\n          // Supprimer l'écouteur d'événement\n          window.removeEventListener('step-execution-progress', this.handleStepProgress);\n        });\n      }).catch(error => {\n        this.isReplaying = false;\n        this.executionStatus = 'Error loading replay service';\n        console.error('Failed to load replayService:', error);\n        alert('Error loading replay service: ' + error.message);\n      });\n    },\n    // Nouvelle méthode pour gérer les événements de progression des étapes\n    handleStepProgress(event) {\n      const {\n        currentStepIndex,\n        results,\n        status\n      } = event.detail;\n      console.log(`Step progress: step ${currentStepIndex + 1}, status: ${status}`);\n\n      // Mettre à jour l'index de l'étape courante pour l'animation\n      this.currentStepIndex = currentStepIndex;\n\n      // Mettre à jour les résultats si disponibles\n      if (results && Array.isArray(results)) {\n        this.replayResults = results;\n      }\n\n      // Mettre à jour le statut d'exécution\n      if (status === 'completed') {\n        this.executionStatus = 'Execution Complete';\n      } else if (status === 'error') {\n        this.executionStatus = 'Error in execution';\n      } else if (status === 'stopped') {\n        this.executionStatus = 'Execution stopped due to error';\n      }\n    },\n    clearResults() {\n      // Clear the local results array\n      this.replayResults = [];\n\n      // Also clear any stored replay progress data\n      chrome.storage.local.remove(['replayProgress', 'replayProgressTimestamp'], () => {\n        console.log('Previous replay results cleared');\n      });\n    },\n    exportReplayResults() {\n      // Préparation des données brutes pour préserver la structure originale\n      const rawRequests = this.recordedRequestsData ?\n      // Utiliser exactement les requêtes originales sans aucune transformation\n      JSON.parse(JSON.stringify(this.recordedRequestsData)) : this.scenarioSteps.map(step => {\n        // Si nous avons le corps original stocké, utiliser celui-là\n        const originalBody = step._originalRequestBody || step.requestBody;\n\n        // Log pour déboguer la structure originale\n        console.log('Exporting original body structure:', JSON.stringify(originalBody, null, 2));\n        return {\n          url: step.url,\n          method: step.method,\n          requestHeaders: step.requestHeaders || {},\n          // Utiliser le corps original sans aucune transformation\n          requestBody: originalBody,\n          body: originalBody,\n          // Copie dupliquée pour assurer la compatibilité\n          responseHeaders: step.responseHeaders || {},\n          // Inclure les captures de variables si elles existent\n          variableCapture: step.variableCaptures || []\n        };\n      });\n\n      // Format d'exportation spécial NON-OpenAPI pour préserver la structure exacte\n      const resultData = {\n        timestamp: new Date().toISOString(),\n        scenario: this.scenario ? this.scenario.info?.title : 'Recorded Requests Replay',\n        description: this.scenario ? this.scenario.info?.description : 'Replay of recorded network requests',\n        executionOptions: this.executionOptions,\n        results: this.replayResults,\n        // Exporter les requêtes exactement comme elles sont, sans transformation\n        rawRequests: rawRequests,\n        // Indicateur pour le format d'exportation\n        exportFormat: {\n          version: \"2.2\",\n          // Version mise à jour pour indiquer la compatibilité améliorée\n          preservesRawStructure: true,\n          date: new Date().toISOString(),\n          preservesOriginalBodyStructure: true,\n          isStandardOpenAPI: false // Indiquer explicitement que ce n'est PAS un format OpenAPI standard\n        }\n      };\n\n      // On n'utilise plus la structure OpenAPI car elle déforme les corps de requêtes\n      // if (this.scenario && !resultData.openapi) {\n      //   resultData.openapi = \"3.0.0\";\n      //   resultData.paths = {};\n      // }\n\n      const blob = new Blob([JSON.stringify(resultData, null, 2)], {\n        type: 'application/json'\n      });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `raw-requests-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;\n\n      // Cleanup pour éviter les fuites de mémoire\n      a.onclick = () => {\n        setTimeout(() => {\n          URL.revokeObjectURL(url);\n        }, 150);\n      };\n      a.click();\n\n      // Notification de succès\n      this.$root.$emit('show-snackbar', {\n        text: 'Le fichier a été exporté avec succès au format RAW préservant la structure exacte de requêtes',\n        color: 'success',\n        timeout: 4000\n      });\n    },\n    generatePdfReport() {\n      try {\n        // Import jsPDF dynamically if not already loaded\n        import('jspdf').then(({\n          jsPDF\n        }) => {\n          import('jspdf-autotable').then(() => {\n            const doc = new jsPDF();\n\n            // Add title\n            doc.setFontSize(20);\n            doc.setTextColor(0, 51, 102);\n            doc.text('Network Request Replay Results', 14, 20);\n\n            // Add timestamp\n            doc.setFontSize(10);\n            doc.setTextColor(100, 100, 100);\n            doc.text(`Generated: ${new Date().toLocaleString()}`, 14, 30);\n\n            // Add scenario info\n            doc.setFontSize(12);\n            doc.setTextColor(0, 0, 0);\n            doc.text(`Scenario: ${this.scenario ? this.scenario.info.title : 'Recorded Requests Replay'}`, 14, 40);\n            if (this.scenario && this.scenario.info.description) {\n              doc.setFontSize(10);\n              doc.text(`Description: ${this.scenario.info.description}`, 14, 47);\n            }\n\n            // Add summary section\n            doc.setFontSize(14);\n            doc.setTextColor(0, 51, 102);\n            doc.text('Execution Summary', 14, 60);\n            const successCount = this.replayResults.filter(r => r.status === 'success').length;\n            const errorCount = this.replayResults.filter(r => r.status === 'error').length;\n            const skippedCount = this.replayResults.filter(r => r.status === 'skipped').length;\n\n            // Summary table\n            doc.autoTable({\n              startY: 65,\n              head: [['Metric', 'Value']],\n              body: [['Total Steps', this.replayResults.length.toString()], ['Successful', successCount.toString()], ['Failed', errorCount.toString()], ['Skipped', skippedCount.toString()], ['Success Rate', `${this.replayResults.length ? Math.round(successCount / this.replayResults.length * 100) : 0}%`]],\n              theme: 'grid',\n              headStyles: {\n                fillColor: [0, 51, 102],\n                textColor: [255, 255, 255]\n              },\n              styles: {\n                overflow: 'linebreak'\n              }\n            });\n\n            // Add results section\n            let yPos = doc.autoTable.previous.finalY + 15;\n            doc.setFontSize(14);\n            doc.setTextColor(0, 51, 102);\n            doc.text('Detailed Results', 14, yPos);\n\n            // Results table\n            const resultRows = this.replayResults.map((result, index) => {\n              return [(index + 1).toString(), result.step, result.status.toUpperCase(), result.status === 'error' ? result.error || 'Error occurred' : 'OK'];\n            });\n\n            // If multiple pages needed, ensure good layout\n            doc.autoTable({\n              startY: yPos + 5,\n              head: [['#', 'Step', 'Status', 'Details']],\n              body: resultRows,\n              theme: 'grid',\n              headStyles: {\n                fillColor: [0, 51, 102],\n                textColor: [255, 255, 255]\n              },\n              styles: {\n                overflow: 'linebreak'\n              },\n              columnStyles: {\n                0: {\n                  cellWidth: 10\n                },\n                2: {\n                  cellWidth: 25\n                }\n              },\n              didDrawCell: data => {\n                // Add color to the status cell based on status\n                if (data.column.index === 2 && data.section === 'body') {\n                  const status = this.replayResults[data.row.index].status;\n                  if (status === 'success') {\n                    doc.setFillColor(0, 128, 0, 0.1); // light green\n                    doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'F');\n                  } else if (status === 'error') {\n                    doc.setFillColor(255, 0, 0, 0.1); // light red\n                    doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'F');\n                  } else if (status === 'skipped') {\n                    doc.setFillColor(255, 165, 0, 0.1); // light orange\n                    doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'F');\n                  }\n                }\n              }\n            });\n\n            // Add footer with page numbers\n            const pageCount = doc.internal.getNumberOfPages();\n            for (let i = 1; i <= pageCount; i++) {\n              doc.setPage(i);\n              doc.setFontSize(10);\n              doc.setTextColor(100, 100, 100);\n              doc.text(`Page ${i} of ${pageCount}`, doc.internal.pageSize.getWidth() / 2, doc.internal.pageSize.getHeight() - 10, {\n                align: 'center'\n              });\n            }\n\n            // Save the PDF\n            doc.save(`replay-report-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.pdf`);\n          });\n        }).catch(error => {\n          console.error('Error loading PDF libraries:', error);\n          alert('Could not generate PDF. Please check console for errors.');\n        });\n      } catch (error) {\n        console.error('Error generating PDF report:', error);\n        alert('Error generating PDF report: ' + error.message);\n      }\n    },\n    clearAllReplayData() {\n      // Use Vuetify dialog for confirmation\n      if (confirm('Are you sure you want to clear all replay data? This action cannot be undone.')) {\n        chrome.storage.local.remove(['latestRecordedData', 'replayWindowData', 'replayWindowDataCount', 'autoLoadLatestRecording', 'replayProgress', 'dataTimestamp'], () => {\n          this.recordedRequestsData = null;\n          this.scenario = null;\n          this.scenarioSteps = [];\n          this.replayResults = [];\n          this.autoLoadedData = false;\n          this.$root.$emit('show-snackbar', {\n            text: 'All replay data has been cleared.',\n            color: 'success'\n          });\n        });\n      }\n    },\n    dumpStorageContents() {\n      chrome.storage.local.get(null, items => {\n        console.log('All storage contents:', Object.keys(items));\n\n        // Check specific data structures\n        if (items.latestRecordedData) {\n          console.log('latestRecordedData info:', {\n            count: items.latestRecordedData.length,\n            firstItem: items.latestRecordedData[0] ? {\n              url: items.latestRecordedData[0].url,\n              method: items.latestRecordedData[0].method\n            } : null\n          });\n        }\n        if (items.replayWindowData) {\n          console.log('replayWindowData info:', {\n            count: items.replayWindowData.length,\n            firstItem: items.replayWindowData[0] ? {\n              url: items.replayWindowData[0].url,\n              method: items.replayWindowData[0].method\n            } : null\n          });\n        }\n      });\n    },\n    showNoDataMessage() {\n      // Add UI indication that no data was found\n      this.executionStatus = 'No recorded data found to replay';\n    },\n    // Add the missing formatJson method\n    formatJson(data) {\n      if (!data) return 'No data available';\n      try {\n        if (typeof data === 'object') {\n          return JSON.stringify(data, null, 2);\n        } else if (typeof data === 'string') {\n          // Try to parse as JSON if it's a string\n          try {\n            const parsed = JSON.parse(data);\n            return JSON.stringify(parsed, null, 2);\n          } catch {\n            // If parsing fails, just return the string\n            return data;\n          }\n        }\n        return String(data);\n      } catch (e) {\n        console.error('Error formatting JSON:', e);\n        return String(data);\n      }\n    },\n    async loadReplayFromFile(event) {\n      try {\n        const file = event.target.files[0];\n        if (!file) {\n          console.error('No file selected');\n          return;\n        }\n        const reader = new FileReader();\n        reader.onload = async e => {\n          try {\n            const fileContent = e.target.result;\n            const jsonData = JSON.parse(fileContent);\n            console.log('File content parsed as JSON:', jsonData);\n\n            // Détection du format de fichier importé\n            if (jsonData.rawRequests && Array.isArray(jsonData.rawRequests)) {\n              // Fichier exporté avec nos modifications pour préserver la structure brute\n              console.log('Detected raw requests format with preserved structure:', jsonData.rawRequests.length);\n              this.recordedRequestsData = jsonData.rawRequests;\n              this.scenarioSteps = await this.replayService.convertRecordedDataToScenario(jsonData.rawRequests);\n            }\n            // Pour la rétrocompatibilité avec les anciens fichiers exportés\n            else if (jsonData.results && Array.isArray(jsonData.results)) {\n              this.recordedRequestsData = jsonData.results.map(result => result.request);\n              this.scenarioSteps = await this.replayService.convertRecordedDataToScenario(jsonData.results.map(result => result.request));\n            }\n            // Pour les fichiers OpenAPI standard\n            else if (jsonData.openapi || jsonData.swagger) {\n              this.scenarioSteps = this.replayService.extractStepsFromOpenAPI(jsonData);\n              console.log('Extracted steps from OpenAPI:', this.scenarioSteps.length);\n            }\n            // Pour les fichiers .har ou d'autres formats similaires\n            else if (jsonData.log && jsonData.log.entries) {\n              const entries = jsonData.log.entries.map(entry => {\n                return {\n                  url: entry.request.url,\n                  method: entry.request.method,\n                  requestHeaders: entry.request.headers.reduce((obj, header) => {\n                    obj[header.name] = header.value;\n                    return obj;\n                  }, {}),\n                  requestBody: this.extractBodyFromHAR(entry.request),\n                  responseHeaders: entry.response.headers.reduce((obj, header) => {\n                    obj[header.name] = header.value;\n                    return obj;\n                  }, {})\n                };\n              });\n              this.recordedRequestsData = entries;\n              this.scenarioSteps = await this.replayService.convertRecordedDataToScenario(entries);\n            }\n            // Si aucun format reconnu, essayer de traiter comme un tableau brut de requêtes\n            else if (Array.isArray(jsonData)) {\n              console.log('Processing array of requests:', jsonData.length);\n              this.recordedRequestsData = jsonData;\n              this.scenarioSteps = await this.replayService.convertRecordedDataToScenario(jsonData);\n            } else {\n              throw new Error('Format de fichier non reconnu');\n            }\n            this.setupScenario();\n\n            // Récupérer les options d'exécution si elles existent\n            if (jsonData.executionOptions) {\n              this.executionOptions = jsonData.executionOptions;\n            }\n\n            // Effacer le fichier sélectionné pour permettre de réimporter le même fichier\n            event.target.value = '';\n            console.log('Loaded steps:', this.scenarioSteps.length);\n          } catch (error) {\n            console.error('Error processing file content:', error);\n            this.showAlert('error', `Erreur lors de l'analyse du fichier: ${error.message}`);\n          }\n        };\n        reader.readAsText(file);\n      } catch (error) {\n        console.error('Error loading file:', error);\n        this.showAlert('error', `Erreur lors du chargement du fichier: ${error.message}`);\n      }\n    },\n    // Nouvelle fonction pour extraire le corps de la requête à partir d'un format HAR\n    extractBodyFromHAR(request) {\n      if (!request.postData) return null;\n\n      // Si le corps est déjà disponible en texte\n      if (request.postData.text) {\n        try {\n          if (request.postData.mimeType.includes('json')) {\n            return JSON.parse(request.postData.text);\n          }\n          return request.postData.text;\n        } catch (e) {\n          return request.postData.text;\n        }\n      }\n\n      // Si le corps est dans un format de paramètres\n      if (request.postData.params && request.postData.params.length > 0) {\n        return request.postData.params.reduce((obj, param) => {\n          obj[param.name] = param.value;\n          return obj;\n        }, {});\n      }\n      return null;\n    },\n    exportToFile() {\n      try {\n        if (!this.recordedRequestsData || this.recordedRequestsData.length === 0) {\n          this.showAlert('error', 'Aucune donnée à exporter');\n          return;\n        }\n\n        // Créer un objet contenant les requêtes brutes et les options d'exécution\n        const exportData = {\n          timestamp: new Date().toISOString(),\n          rawRequests: this.recordedRequestsData,\n          executionOptions: this.executionOptions || {}\n        };\n        const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n          type: 'application/json'\n        });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `network-recording-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;\n        a.click();\n        setTimeout(() => {\n          URL.revokeObjectURL(url);\n        }, 150);\n        this.showAlert('success', 'Export réussi!');\n      } catch (error) {\n        console.error('Error exporting data:', error);\n        this.showAlert('error', `Erreur lors de l'exportation: ${error.message}`);\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}