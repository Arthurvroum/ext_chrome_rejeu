{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nexport default {\n  name: 'StepsList',\n  props: {\n    steps: {\n      type: Array,\n      required: true\n    },\n    expandedStep: {\n      type: Number,\n      default: null\n    },\n    isReplaying: {\n      type: Boolean,\n      default: false\n    },\n    results: {\n      type: Array,\n      default: () => []\n    },\n    currentStepIndex: {\n      type: Number,\n      default: -1\n    },\n    showRuntimeProgress: {\n      type: Boolean,\n      default: true // Toujours vrai maintenant, on ignore cette prop\n    },\n    executionOptions: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  data() {\n    return {\n      localActiveTabs: {},\n      // Store active tab for each step\n      progressStatus: {},\n      // Store runtime progress status for steps\n      captureSourceOptions: [{\n        title: 'Corps de la réponse',\n        value: 'body'\n      }, {\n        title: 'En-têtes de la réponse',\n        value: 'headers'\n      }, {\n        title: 'URL de la réponse',\n        value: 'url'\n      }],\n      showCaptureDialog: false,\n      captureForm: {\n        name: '',\n        regex: '',\n        source: 'body',\n        required: false\n      },\n      captureStepIndex: null,\n      showSubstitutionDialog: false,\n      substitutionForm: {\n        regex: '',\n        mode: 'variable',\n        sourceStep: null,\n        targetVariable: '',\n        value: ''\n      }\n    };\n  },\n  computed: {\n    hasResults() {\n      return this.results && this.results.length > 0;\n    },\n    successCount() {\n      return this.results.filter(r => r.status === 'success').length;\n    },\n    errorCount() {\n      return this.results.filter(r => r.status === 'error').length;\n    },\n    skippedCount() {\n      return this.results.filter(r => r.status === 'skipped').length;\n    },\n    availableStepsForVariables() {\n      return this.steps.map((step, index) => ({\n        label: `Étape ${index + 1}: ${step.name || step.url}`,\n        value: index\n      }));\n    }\n  },\n  created() {\n    // Écouter les événements de progression en temps réel\n    window.addEventListener('step-execution-progress', this.handleStepProgress);\n    console.log('StepsList: Listening for step-execution-progress events');\n  },\n  beforeUnmount() {\n    // Nettoyer les écouteurs d'événements\n    window.removeEventListener('step-execution-progress', this.handleStepProgress);\n  },\n  methods: {\n    updateStepEnabled(index, enabled) {\n      const updatedStep = {\n        enabled,\n        skip: !enabled\n      };\n      this.$emit('update-step', index, updatedStep);\n    },\n    toggleStep(index) {\n      this.$emit('toggle-step', index);\n\n      // Initialize tab for this step if not already set\n      if (!this.localActiveTabs[index]) {\n        // Remplacer this.$set par l'affectation directe (Vue 3)\n        this.localActiveTabs = {\n          ...this.localActiveTabs,\n          [index]: 'details'\n        };\n      }\n    },\n    getMethodColor(method) {\n      const colors = {\n        GET: 'primary',\n        POST: 'success',\n        PUT: 'warning',\n        DELETE: 'error',\n        PATCH: 'info'\n      };\n      return colors[method] || 'grey';\n    },\n    hasVariables(step) {\n      return step.variableSubstitutions && step.variableSubstitutions.length > 0 || step.variableCaptures && step.variableCaptures.length > 0;\n    },\n    hasResult(index) {\n      return this.results && this.results[index];\n    },\n    getStepResultStatus(index) {\n      // Priorité au statut de progression en temps réel s'il existe\n      if (this.progressStatus[index]) {\n        return this.progressStatus[index];\n      }\n\n      // Sinon, utiliser le résultat de l'exécution finale\n      if (!this.results || this.results.length <= index) {\n        return null;\n      }\n      const result = this.results[index];\n      if (!result) return null;\n      if (result.error) return 'error';\n      return 'success';\n    },\n    hasCapturedVariables(index) {\n      return this.results && this.results[index] && this.results[index].capturedVariables && Object.keys(this.results[index].capturedVariables).length > 0;\n    },\n    hasResultError(index) {\n      return this.results && this.results[index] && this.results[index].status === 'error' && this.results[index].error;\n    },\n    getResultError(index) {\n      if (!this.hasResultError(index)) return '';\n      return this.results[index].error;\n    },\n    getStatusColor(status) {\n      if (status === 'success') return 'success';\n      if (status === 'error') return 'error';\n      if (status === 'skipped') return 'warning';\n      if (status === 'in-progress') return 'info';\n      return 'grey';\n    },\n    getStatusIcon(status) {\n      if (status === 'success') return 'mdi-check';\n      if (status === 'error') return 'mdi-close';\n      if (status === 'skipped') return 'mdi-skip-next';\n      if (status === 'in-progress') return 'mdi-loading';\n      return 'mdi-help';\n    },\n    formatRequestForDisplay(request) {\n      if (!request) return 'No request data available';\n      try {\n        // Create a simplified request object with only essential information\n        const simplifiedRequest = {\n          url: request.url || '',\n          method: request.method || '',\n          headers: request.headers || request.requestHeaders || {}\n        };\n\n        // Add query parameters\n        if (request.queryParameters) {\n          simplifiedRequest.queryParameters = request.queryParameters;\n        } else if (request.url && request.url.includes('?')) {\n          try {\n            const url = new URL(request.url);\n            const params = {};\n            url.searchParams.forEach((value, key) => {\n              params[key] = value;\n            });\n            simplifiedRequest.queryParameters = params;\n          } catch (e) {\n            console.warn('Error parsing URL query parameters:', e);\n          }\n        }\n\n        // Add body only if it exists with multiple source support\n        if (request.body || request.requestBody) {\n          try {\n            const body = request.body || request.requestBody;\n\n            // Handle string bodies (try to parse as JSON)\n            if (typeof body === 'string') {\n              try {\n                simplifiedRequest.body = JSON.parse(body);\n              } catch {\n                simplifiedRequest.body = body;\n              }\n            } else {\n              simplifiedRequest.body = body;\n            }\n          } catch (e) {\n            simplifiedRequest.body = \"Error parsing request body\";\n            console.error('Error parsing body:', e);\n          }\n        }\n        return JSON.stringify(simplifiedRequest, null, 2);\n      } catch (e) {\n        console.error('Error formatting request for display:', e);\n        return `Error formatting request: ${e.message}\\n\\nOriginal request: ${JSON.stringify(request)}`;\n      }\n    },\n    formatJson(data) {\n      if (!data) return 'No data available';\n      try {\n        if (typeof data === 'object') {\n          return JSON.stringify(data, null, 2);\n        } else if (typeof data === 'string') {\n          try {\n            const parsed = JSON.parse(data);\n            return JSON.stringify(parsed, null, 2);\n          } catch {\n            // If it's a string but not JSON, just return the string\n            return data;\n          }\n        } else {\n          return String(data);\n        }\n      } catch (e) {\n        console.error('Error formatting JSON:', e);\n        return `Error formatting data: ${e.message}`;\n      }\n    },\n    // Gestion des événements de progression en temps réel\n    handleStepProgress(event) {\n      console.log('Step progress event received:', event.detail);\n      const {\n        currentStepIndex,\n        status\n      } = event.detail;\n\n      // Mettre à jour le statut de progression pour cette étape\n      if (currentStepIndex >= 0) {\n        this.progressStatus = {\n          ...this.progressStatus,\n          [currentStepIndex]: status\n        };\n      }\n\n      // Si le statut est 'stopped' ou 'completed', on efface le statut de progression\n      if (status === 'stopped' || status === 'completed') {\n        console.log('Clearing progress status - execution completed or stopped');\n        this.progressStatus = {};\n      }\n    },\n    formatStepRequestForDisplay(step) {\n      if (!step) return 'No step data available';\n      try {\n        // Create a simplified step object with only essential information\n        const simplifiedStep = {\n          url: step.url || '',\n          method: step.method || '',\n          headers: step.headers || {}\n        };\n\n        // Add query parameters\n        if (step.queryParameters) {\n          simplifiedStep.queryParameters = step.queryParameters;\n        } else if (step.url && step.url.includes('?')) {\n          try {\n            const url = new URL(step.url);\n            const params = {};\n            url.searchParams.forEach((value, key) => {\n              params[key] = value;\n            });\n            simplifiedStep.queryParameters = params;\n          } catch (e) {\n            console.warn('Error parsing URL query parameters:', e);\n          }\n        }\n\n        // Add body from any of the possible sources where it might be stored\n        if (step.body) {\n          simplifiedStep.body = this.extractBodyContent(step.body);\n        } else if (step.requestBody) {\n          simplifiedStep.body = this.extractBodyContent(step.requestBody);\n        } else if (step._originalRequestBody) {\n          simplifiedStep.body = this.extractBodyContent(step._originalRequestBody);\n        } else if (step.request && step.request.body) {\n          simplifiedStep.body = this.extractBodyContent(step.request.body);\n        }\n        return JSON.stringify(simplifiedStep, null, 2);\n      } catch (e) {\n        console.error('Error formatting step for display:', e);\n        return `Error formatting step: ${e.message}\\n\\nOriginal step: ${JSON.stringify(step)}`;\n      }\n    },\n    extractBodyContent(body) {\n      // Handle Odoo-specific format with content wrapper\n      if (body && body.content && body.content['application/json']) {\n        return body; // Return the complete structure as is\n      }\n\n      // Handle string bodies (try to parse as JSON)\n      if (typeof body === 'string') {\n        try {\n          return JSON.parse(body);\n        } catch {\n          return body; // Return as is if not valid JSON\n        }\n      }\n\n      // Return object as is\n      return body;\n    },\n    // Nouvelles méthodes pour la gestion des captures de variables\n    getStepCaptures(stepIndex) {\n      if (!this.steps[stepIndex].variableCaptures) {\n        // Initialisation des captures si elles n'existent pas encore pour Vue 3\n        this.$emit('update-step', stepIndex, {\n          ...this.steps[stepIndex],\n          variableCaptures: []\n        });\n        return [];\n      }\n      return this.steps[stepIndex].variableCaptures;\n    },\n    addCapture(stepIndex) {\n      const step = this.steps[stepIndex];\n      const captures = step.variableCaptures || [];\n\n      // Création d'une nouvelle capture par défaut\n      const newCapture = {\n        name: `variable_${captures.length + 1}`,\n        regex: '',\n        source: 'body',\n        required: false\n      };\n\n      // Ajout de la nouvelle capture\n      const updatedCaptures = [...captures, newCapture];\n\n      // Mise à jour de l'étape avec Vue 3\n      this.$emit('update-step', stepIndex, {\n        ...step,\n        variableCaptures: updatedCaptures\n      });\n    },\n    removeCapture(stepIndex, captureIndex) {\n      const step = this.steps[stepIndex];\n      const captures = [...step.variableCaptures];\n\n      // Suppression de la capture\n      captures.splice(captureIndex, 1);\n\n      // Mise à jour de l'étape avec Vue 3\n      this.$emit('update-step', stepIndex, {\n        ...step,\n        variableCaptures: captures\n      });\n    },\n    getSourceLabel(source) {\n      const found = this.captureSourceOptions.find(opt => opt.value === source);\n      return found ? found.title : source;\n    },\n    openCaptureDialog(stepIndex) {\n      this.captureForm = {\n        name: '',\n        regex: '',\n        source: 'body',\n        required: false\n      };\n      this.captureStepIndex = stepIndex;\n      this.showCaptureDialog = true;\n    },\n    saveCapture() {\n      if (!this.captureForm.name || !this.captureForm.regex) return;\n      const stepIndex = this.captureStepIndex;\n      const step = this.steps[stepIndex];\n      const captures = step.variableCaptures || [];\n      const newCapture = {\n        ...this.captureForm\n      };\n      const updatedCaptures = [...captures, newCapture];\n      this.$emit('update-step', stepIndex, {\n        ...step,\n        variableCaptures: updatedCaptures\n      });\n      this.showCaptureDialog = false;\n    },\n    getModifiedUrl(originalUrl, baseUrl) {\n      if (!baseUrl || !originalUrl) {\n        return originalUrl;\n      }\n      try {\n        // Analyser l'URL originale\n        const urlObj = new URL(originalUrl);\n\n        // Analyser la baseUrl\n        let baseUrlObj;\n        try {\n          // S'assurer que la baseUrl a un protocole\n          if (!baseUrl.startsWith('http://') && !baseUrl.startsWith('https://')) {\n            baseUrlObj = new URL('http://' + baseUrl);\n          } else {\n            baseUrlObj = new URL(baseUrl);\n          }\n        } catch (e) {\n          console.warn('Invalid baseUrl format:', baseUrl, e);\n          return originalUrl;\n        }\n\n        // Construire la nouvelle URL en conservant le chemin et les paramètres\n        // mais en remplaçant le protocole, l'hôte et le port\n        const newUrl = new URL(urlObj.pathname + urlObj.search + urlObj.hash, baseUrlObj.origin);\n        return newUrl.href;\n      } catch (e) {\n        console.warn('Error applying baseUrl:', e);\n        return originalUrl;\n      }\n    },\n    openSubstitutionDialog(stepIndex) {\n      this.substitutionForm = {\n        regex: '',\n        mode: 'variable',\n        sourceStep: null,\n        targetVariable: '',\n        value: ''\n      };\n      this.substitutionStepIndex = stepIndex;\n      this.showSubstitutionDialog = true;\n    },\n    saveSubstitution() {\n      if (!this.substitutionForm.regex) return;\n      const stepIndex = this.substitutionStepIndex;\n      const step = this.steps[stepIndex];\n      const substitutions = step.variableSubstitutions || [];\n\n      // Créer la structure de substitution selon le mode sélectionné\n      let newSubstitution = {\n        regex: this.substitutionForm.regex\n      };\n      if (this.substitutionForm.mode === 'variable') {\n        // Mode variable: utiliser une variable capturée précédemment\n        newSubstitution = {\n          ...newSubstitution,\n          mode: 'variable',\n          targetVariable: this.substitutionForm.targetVariable,\n          sourceStep: this.substitutionForm.sourceStep\n        };\n\n        // Ajouter un log pour le débogage\n        console.log('[SUBSTITUTION] Ajout d\\'une substitution de variable:', `regex=${newSubstitution.regex}, ` + `targetVariable=${newSubstitution.targetVariable}`);\n      } else {\n        // Mode valeur fixe\n        newSubstitution = {\n          ...newSubstitution,\n          mode: 'fixed',\n          value: this.substitutionForm.value\n        };\n\n        // Ajouter un log pour le débogage\n        console.log('[SUBSTITUTION] Ajout d\\'une substitution de valeur fixe:', `regex=${newSubstitution.regex}, ` + `value=${newSubstitution.value}`);\n      }\n      const updatedSubstitutions = [...substitutions, newSubstitution];\n\n      // Log pour le débogage\n      console.log('[SUBSTITUTION] État des substitutions après ajout:', updatedSubstitutions);\n\n      // Mise à jour de l'étape\n      this.$emit('update-step', stepIndex, {\n        ...step,\n        variableSubstitutions: updatedSubstitutions\n      });\n      this.showSubstitutionDialog = false;\n    },\n    getStepSubstitutions(stepIndex) {\n      if (!this.steps[stepIndex].variableSubstitutions) {\n        // Initialisation des substitutions si elles n'existent pas encore pour Vue 3\n        this.$emit('update-step', stepIndex, {\n          ...this.steps[stepIndex],\n          variableSubstitutions: []\n        });\n        return [];\n      }\n      return this.steps[stepIndex].variableSubstitutions;\n    },\n    availableVariablesForStep(stepIndex) {\n      // Initialiser le tableau de variables disponibles\n      let availableVars = [];\n\n      // 1. Collecter toutes les variables définies dans les étapes précédentes\n      for (let i = 0; i < stepIndex; i++) {\n        const step = this.steps[i];\n        if (step && step.variableCaptures && step.variableCaptures.length > 0) {\n          // Ajouter les noms des variables définies dans cette étape\n          const stepVars = step.variableCaptures.map(capture => capture.name);\n          availableVars = [...availableVars, ...stepVars];\n        }\n      }\n\n      // 2. Ajouter les variables effectivement capturées lors d'une exécution précédente\n      if (this.results) {\n        for (let i = 0; i < stepIndex; i++) {\n          if (this.results[i] && this.results[i].capturedVariables) {\n            const capturedVars = Object.keys(this.results[i].capturedVariables);\n            availableVars = [...availableVars, ...capturedVars];\n          }\n        }\n      }\n\n      // Éliminer les doublons et retourner un tableau unique\n      const uniqueVars = [...new Set(availableVars)];\n\n      // Message spécifique pour l'étape 0 où il est normal de ne pas avoir de variables\n      if (stepIndex === 0) {\n        console.log('Étape 0: Aucune variable disponible (normale car c\\'est la première étape)');\n        return ['Aucune variable disponible - Définissez des variables dans cette étape pour les étapes suivantes'];\n      }\n\n      // Si aucune variable n'est disponible, retourner un message explicatif\n      if (uniqueVars.length === 0) {\n        console.log('Aucune variable disponible pour l\\'étape', stepIndex);\n        return ['Définissez des variables dans les étapes précédentes pour les utiliser ici'];\n      }\n      console.log('Variables disponibles pour l\\'étape', stepIndex, ':', uniqueVars);\n      return uniqueVars;\n    },\n    removeSubstitution(stepIndex, subIndex) {\n      const step = this.steps[stepIndex];\n      const substitutions = [...step.variableSubstitutions];\n\n      // Suppression de la substitution\n      substitutions.splice(subIndex, 1);\n\n      // Mise à jour de l'étape avec Vue 3\n      this.$emit('update-step', stepIndex, {\n        ...step,\n        variableSubstitutions: substitutions\n      });\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}