{"ast":null,"code":"import \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { sendMessageToBackground, sendMessageToTab, getActiveTab, isRestrictedUrl, injectContentScript, checkContentScriptReady } from '../utils/chromeApi';\n\n/**\n * Service for handling network request recording\n */\nconst recordService = {\n  /**\n   * Get current recording status\n   * @returns {Promise} - Promise that resolves with the recording status\n   */\n  async getRecordingStatus() {\n    try {\n      const response = await sendMessageToBackground({\n        action: 'getRecordingStatus'\n      });\n      return response;\n    } catch (error) {\n      console.error('Error getting recording status:', error);\n      return {\n        isRecording: false,\n        error: error.message\n      };\n    }\n  },\n  /**\n   * Start recording network requests\n   * @returns {Promise} - Promise that resolves when recording starts\n   */\n  async startRecording() {\n    try {\n      // Get active tab\n      const activeTab = await getActiveTab();\n\n      // Check if URL is restricted\n      if (isRestrictedUrl(activeTab.url)) {\n        return {\n          status: 'error',\n          error: 'Cannot record from restricted URLs like browser pages or extension pages',\n          restrictedUrl: true\n        };\n      }\n\n      // Ensure content script is ready\n      const isReady = await checkContentScriptReady(activeTab.id);\n      if (!isReady) {\n        try {\n          await injectContentScript(activeTab.id);\n          // Wait a bit for the script to initialize\n          await new Promise(resolve => setTimeout(resolve, 200));\n        } catch (error) {\n          console.warn('Error injecting content script:', error);\n          // Continue anyway - some features may not work\n        }\n      }\n\n      // Start recording\n      const response = await sendMessageToBackground({\n        action: 'startRecording',\n        tabId: activeTab.id\n      });\n\n      // Notify content script to start observing\n      try {\n        await sendMessageToTab(activeTab.id, {\n          action: 'startObserving'\n        });\n      } catch (error) {\n        console.warn('Error notifying content script:', error);\n      }\n      return response;\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      return {\n        status: 'error',\n        error: error.message\n      };\n    }\n  },\n  /**\n   * Stop recording network requests\n   * @returns {Promise} - Promise that resolves with the recorded data\n   */\n  async stopRecording() {\n    try {\n      // Stop recording in background script\n      const response = await sendMessageToBackground({\n        action: 'stopRecording'\n      });\n\n      // Get active tab\n      const activeTab = await getActiveTab();\n\n      // Notify content script to stop observing\n      try {\n        await sendMessageToTab(activeTab.id, {\n          action: 'stopObserving'\n        });\n      } catch (error) {\n        console.warn('Error notifying content script:', error);\n      }\n      return response;\n    } catch (error) {\n      console.error('Error stopping recording:', error);\n      return {\n        status: 'error',\n        error: error.message\n      };\n    }\n  },\n  /**\n   * Export recorded requests as OpenAPI 3.0 format\n   * @param {Array} requests - The recorded requests to export\n   * @returns {Promise} - Promise that resolves when export is complete\n   */\n  async exportAsOpenAPI(requests) {\n    try {\n      const response = await sendMessageToBackground({\n        action: 'convertToOpenAPI',\n        data: requests\n      });\n      if (response && response.openApiSpec) {\n        // Create downloadable file\n        const blob = new Blob([JSON.stringify(response.openApiSpec, null, 2)], {\n          type: 'application/json'\n        });\n        const url = URL.createObjectURL(blob);\n\n        // Create download link\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = 'recorded-requests.json';\n        document.body.appendChild(a);\n        a.click();\n\n        // Clean up\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        return {\n          success: true\n        };\n      } else {\n        throw new Error('Failed to convert to OpenAPI format');\n      }\n    } catch (error) {\n      console.error('Error exporting as OpenAPI:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  },\n  /**\n   * Open replay in a new tab with the recorded data\n   * @param {Array} recordedRequests - The recorded requests to replay\n   * @returns {Promise} - Promise that resolves when replay tab is opened\n   */\n  async openReplayInNewTab(recordedRequests) {\n    try {\n      // Create a deep copy of the data to avoid reference issues\n      const requestsToSend = JSON.parse(JSON.stringify(recordedRequests));\n\n      // Save data to storage for replay tab to access\n      await chrome.storage.local.set({\n        latestRecordedData: requestsToSend,\n        replayWindowData: requestsToSend,\n        replayWindowDataCount: requestsToSend.length,\n        autoLoadLatestRecording: true,\n        recordingTimestamp: Date.now()\n      });\n\n      // Open replay tab\n      const response = await sendMessageToBackground({\n        action: 'openReplayWindow',\n        data: requestsToSend,\n        count: requestsToSend.length\n      });\n      return response;\n    } catch (error) {\n      console.error('Error opening replay tab:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n};\nexport default recordService;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}