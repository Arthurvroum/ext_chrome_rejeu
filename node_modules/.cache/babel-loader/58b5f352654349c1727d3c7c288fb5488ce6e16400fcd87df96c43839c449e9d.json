{"ast":null,"code":"import \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { sendMessageToBackground, sendMessageToTab, getActiveTab, isRestrictedUrl, injectContentScript, checkContentScriptReady } from '../utils/chromeApi';\nimport { isRelativeUrl } from '../utils/formatting';\nlet lastReplayTabOpenTime = 0;\nconst MIN_INTERVAL_BETWEEN_TABS = 2000; // 2 seconds minimum between tab opens\n\n/**\n * Service for handling network request recording\n */\nconst recordService = {\n  /**\n   * Get current recording status\n   * @returns {Promise} - Promise that resolves with the recording status\n   */\n  async getRecordingStatus() {\n    try {\n      const response = await sendMessageToBackground({\n        action: 'getRecordingStatus'\n      });\n      return response;\n    } catch (error) {\n      console.error('Error getting recording status:', error);\n      return {\n        isRecording: false,\n        error: error.message\n      };\n    }\n  },\n  /**\n   * Start recording network requests\n   * @returns {Promise} - Promise that resolves when recording starts\n   */\n  async startRecording() {\n    try {\n      // Get active tab\n      const activeTab = await getActiveTab();\n\n      // Check if URL is restricted\n      if (isRestrictedUrl(activeTab.url)) {\n        return {\n          status: 'error',\n          error: 'Cannot record from restricted URLs like browser pages or extension pages',\n          restrictedUrl: true\n        };\n      }\n\n      // Ensure content script is ready\n      const isReady = await checkContentScriptReady(activeTab.id);\n      if (!isReady) {\n        try {\n          await injectContentScript(activeTab.id);\n          // Wait a bit for the script to initialize\n          await new Promise(resolve => setTimeout(resolve, 200));\n        } catch (error) {\n          console.warn('Error injecting content script:', error);\n          // Continue anyway - some features may not work\n        }\n      }\n\n      // Start recording\n      const response = await sendMessageToBackground({\n        action: 'startRecording',\n        tabId: activeTab.id\n      });\n\n      // Notify content script to start observing\n      try {\n        await sendMessageToTab(activeTab.id, {\n          action: 'startObserving'\n        });\n      } catch (error) {\n        console.warn('Error notifying content script:', error);\n      }\n      return response;\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      return {\n        status: 'error',\n        error: error.message\n      };\n    }\n  },\n  /**\n   * Stop recording network requests\n   * @returns {Promise} - Promise that resolves with the recorded data\n   */\n  async stopRecording() {\n    try {\n      // Stop recording in background script\n      const response = await sendMessageToBackground({\n        action: 'stopRecording'\n      });\n\n      // Get active tab\n      const activeTab = await getActiveTab();\n\n      // Notify content script to stop observing\n      try {\n        await sendMessageToTab(activeTab.id, {\n          action: 'stopObserving'\n        });\n      } catch (error) {\n        console.warn('Error notifying content script:', error);\n      }\n      return response;\n    } catch (error) {\n      console.error('Error stopping recording:', error);\n      return {\n        status: 'error',\n        error: error.message\n      };\n    }\n  },\n  /**\n   * Export recorded requests as OpenAPI 3.0 format\n   * @param {Array} requests - The recorded requests to export\n   * @returns {Promise} - Promise that resolves when export is complete\n   */\n  async exportAsOpenAPI(requests) {\n    try {\n      const response = await sendMessageToBackground({\n        action: 'convertToOpenAPI',\n        data: requests\n      });\n      if (response && response.openApiSpec) {\n        // Validate the OpenAPI spec\n        validateOpenApiSpec(response.openApiSpec);\n\n        // Create downloadable file\n        const blob = new Blob([JSON.stringify(response.openApiSpec, null, 2)], {\n          type: 'application/json'\n        });\n        const url = URL.createObjectURL(blob);\n\n        // Create download link\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = 'recorded-requests.json';\n        document.body.appendChild(a);\n        a.click();\n\n        // Clean up\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        return {\n          success: true\n        };\n      } else {\n        throw new Error('Failed to convert to OpenAPI format');\n      }\n    } catch (error) {\n      console.error('Error exporting as OpenAPI:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  },\n  /**\n   * Open replay in a new tab with the recorded data\n   * @param {Array} recordedRequests - The recorded requests to replay (can be empty)\n   * @returns {Promise} - Promise that resolves when replay tab is opened\n   */\n  async openReplayInNewTab(recordedRequests = []) {\n    // Prevent multiple calls within a short time period\n    const now = Date.now();\n    if (now - lastReplayTabOpenTime < MIN_INTERVAL_BETWEEN_TABS) {\n      console.log('Ignoring duplicate openReplayInNewTab call', 'Last call:', lastReplayTabOpenTime, 'Current time:', now, 'Difference:', now - lastReplayTabOpenTime);\n      return {\n        success: false,\n        error: 'Too many requests. Try again in a moment.'\n      };\n    }\n    lastReplayTabOpenTime = now;\n    try {\n      // Create a deep copy of the data to avoid reference issues\n      // If no requests are provided, use an empty array\n      const requestsToSend = recordedRequests ? JSON.parse(JSON.stringify(recordedRequests)) : [];\n\n      // Use a unique timestamp for this data to prevent confusion with previous requests\n      const dataTimestamp = Date.now();\n\n      // Save data to storage for replay tab to access\n      await chrome.storage.local.set({\n        latestRecordedData: requestsToSend,\n        replayWindowData: requestsToSend,\n        replayWindowDataCount: requestsToSend.length,\n        autoLoadLatestRecording: true,\n        recordingTimestamp: dataTimestamp,\n        lastReplayTabRequest: dataTimestamp // Mark when we last requested a tab\n      });\n\n      // Open replay tab with a unique timestamp to prevent caching\n      const response = await sendMessageToBackground({\n        action: 'openReplayWindow',\n        data: requestsToSend,\n        count: requestsToSend.length,\n        timestamp: dataTimestamp // Add timestamp to make each request unique\n      });\n      return response;\n    } catch (error) {\n      console.error('Error opening replay tab:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n};\n\n// Validate the OpenAPI spec has the minimum required fields\nfunction validateOpenApiSpec(spec) {\n  if (!spec.openapi || !spec.openapi.startsWith('3.0')) {\n    console.warn('Warning: OpenAPI version should be 3.0.x');\n  }\n  if (!spec.info) {\n    console.warn('Warning: Missing info object in OpenAPI spec');\n  }\n  if (!spec.paths || Object.keys(spec.paths).length === 0) {\n    console.warn('Warning: No paths defined in OpenAPI spec');\n  }\n\n  // Check for x-original-urls map\n  if (!spec['x-original-urls'] || Object.keys(spec['x-original-urls']).length === 0) {\n    console.warn('Warning: Missing x-original-urls map for proper replay');\n  }\n  return true;\n}\nexport default recordService;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}