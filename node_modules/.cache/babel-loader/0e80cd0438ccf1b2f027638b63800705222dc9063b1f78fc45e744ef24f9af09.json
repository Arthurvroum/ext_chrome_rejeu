{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { computed } from 'vue';\n\n/**\n * Composable pour gérer les résultats des étapes\n * @param {Object} props - Les propriétés contenant les étapes\n * @returns {Object} - Fonctions et propriétés pour analyser les résultats\n */\nexport default function useStepResults(props) {\n  /**\n   * Obtenir le statut du résultat d'une étape\n   * @param {Number} index - L'index de l'étape\n   * @returns {String} - Le statut (success, error, skipped, pending)\n   */\n  const getStepResultStatus = index => {\n    if (!props.steps || index < 0 || index >= props.steps.length) {\n      return 'pending';\n    }\n    const step = props.steps[index];\n    if (step.skip) {\n      return 'skipped';\n    }\n    if (!step.result) {\n      return 'pending';\n    }\n    if (step.result.error) {\n      return 'error';\n    }\n    return 'success';\n  };\n\n  /**\n   * Formater la réponse pour l'affichage\n   * @param {Object} response - La réponse à formater\n   * @returns {String} - La réponse formatée\n   */\n  const formatResponse = response => {\n    if (!response) return '';\n    try {\n      // Si la réponse est un objet, la formater joliment\n      if (typeof response === 'object') {\n        return JSON.stringify(response, null, 2);\n      }\n\n      // Essayer de parser la réponse comme JSON si elle est une chaîne\n      const parsed = JSON.parse(response);\n      return JSON.stringify(parsed, null, 2);\n    } catch (e) {\n      // Si ce n'est pas du JSON valide, retourner tel quel\n      return response;\n    }\n  };\n\n  /**\n   * Formater l'URL pour l'affichage\n   * @param {String} url - L'URL à formater\n   * @returns {String} - L'URL formatée\n   */\n  const formatUrl = url => {\n    if (!url) return '';\n\n    // Ajouter http:// si nécessaire\n    if (!url.startsWith('http://') && !url.startsWith('https://')) {\n      return `http://${url}`;\n    }\n    return url;\n  };\n\n  /**\n   * Formater les en-têtes pour l'affichage\n   * @param {Object} headers - Les en-têtes à formater\n   * @returns {String} - Les en-têtes formatés\n   */\n  const formatHeaders = headers => {\n    if (!headers) return '';\n    try {\n      if (typeof headers === 'string') {\n        // Essayer de parser les en-têtes comme JSON\n        return JSON.stringify(JSON.parse(headers), null, 2);\n      }\n      return JSON.stringify(headers, null, 2);\n    } catch (e) {\n      return headers;\n    }\n  };\n\n  /**\n   * Formater le corps de la requête pour l'affichage\n   * @param {Object|String} body - Le corps à formater\n   * @returns {String} - Le corps formaté\n   */\n  const formatBody = body => {\n    if (!body) return '';\n    try {\n      if (typeof body === 'string') {\n        // Essayer de parser le corps comme JSON\n        return JSON.stringify(JSON.parse(body), null, 2);\n      }\n      return JSON.stringify(body, null, 2);\n    } catch (e) {\n      return body;\n    }\n  };\n\n  /**\n   * Obtenir un résumé des résultats des étapes\n   */\n  const resultsSummary = computed(() => {\n    if (!props.steps || props.steps.length === 0) {\n      return {\n        total: 0,\n        success: 0,\n        error: 0,\n        skipped: 0\n      };\n    }\n    const total = props.steps.length;\n    const success = props.steps.filter((step, idx) => getStepResultStatus(idx) === 'success').length;\n    const error = props.steps.filter((step, idx) => getStepResultStatus(idx) === 'error').length;\n    const skipped = props.steps.filter(step => step.skip).length;\n    return {\n      total,\n      success,\n      error,\n      skipped\n    };\n  });\n\n  // Format the response time in a human-readable format\n  function formatResponseTime(timeInMs) {\n    if (!timeInMs && timeInMs !== 0) return 'N/A';\n    if (timeInMs < 1000) {\n      return `${Math.round(timeInMs)}ms`;\n    } else {\n      return `${(timeInMs / 1000).toFixed(2)}s`;\n    }\n  }\n\n  // Format response headers for display\n  function formatResponseHeaders(headers) {\n    if (!headers) return {};\n\n    // Convert headers to object if it's an array or Headers object\n    let headerObj = headers;\n    if (headers instanceof Headers) {\n      headerObj = {};\n      headers.forEach((value, key) => {\n        headerObj[key] = value;\n      });\n    } else if (Array.isArray(headers)) {\n      headerObj = {};\n      headers.forEach(header => {\n        if (header.name && header.value !== undefined) {\n          headerObj[header.name] = header.value;\n        }\n      });\n    }\n    return headerObj;\n  }\n\n  // Format response body for display based on content type\n  function formatResponseBody(result) {\n    if (!result || !result.response) return '';\n    const {\n      response\n    } = result;\n    if (!response.body) return '';\n\n    // Try to determine content type\n    let contentType = '';\n    if (response.headers) {\n      const headers = formatResponseHeaders(response.headers);\n      contentType = headers['content-type'] || headers['Content-Type'] || '';\n    }\n\n    // Format based on content type\n    if (typeof response.body === 'string') {\n      if (contentType.includes('application/json')) {\n        try {\n          const jsonObj = JSON.parse(response.body);\n          return JSON.stringify(jsonObj, null, 2);\n        } catch (e) {\n          return response.body;\n        }\n      } else if (contentType.includes('application/xml') || contentType.includes('text/xml') || response.body.trim().startsWith('<?xml')) {\n        // Simple indentation for XML, could be enhanced with a proper XML formatter\n        return response.body;\n      } else {\n        return response.body;\n      }\n    } else if (typeof response.body === 'object') {\n      try {\n        return JSON.stringify(response.body, null, 2);\n      } catch (e) {\n        return String(response.body);\n      }\n    }\n    return String(response.body);\n  }\n\n  // Get step execution duration\n  function getStepDuration(index) {\n    if (!props.steps || !props.steps[index] || !props.steps[index].response) {\n      return null;\n    }\n    return props.steps[index].response.duration;\n  }\n\n  // Format status code with color\n  function getStatusCodeWithColor(statusCode) {\n    if (!statusCode) return {\n      code: 'N/A',\n      color: 'grey'\n    };\n    let color = 'grey';\n    if (statusCode >= 200 && statusCode < 300) {\n      color = 'success';\n    } else if (statusCode >= 300 && statusCode < 400) {\n      color = 'info';\n    } else if (statusCode >= 400 && statusCode < 500) {\n      color = 'warning';\n    } else if (statusCode >= 500) {\n      color = 'error';\n    }\n    return {\n      code: statusCode,\n      color\n    };\n  }\n\n  // Check if response has body\n  function hasResponseBody(index) {\n    if (!props.steps || !props.steps[index] || !props.steps[index].response) {\n      return false;\n    }\n    const {\n      response\n    } = props.steps[index];\n    return response.body !== undefined && response.body !== null && response.body !== '';\n  }\n  return {\n    getStepResultStatus,\n    formatResponse,\n    formatUrl,\n    formatHeaders,\n    formatBody,\n    resultsSummary,\n    formatResponseTime,\n    formatResponseHeaders,\n    formatResponseBody,\n    getStepDuration,\n    getStatusCodeWithColor,\n    hasResponseBody\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}