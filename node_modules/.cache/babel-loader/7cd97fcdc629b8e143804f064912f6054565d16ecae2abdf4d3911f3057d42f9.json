{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nexport default {\n  name: 'StepsList',\n  props: {\n    steps: {\n      type: Array,\n      required: true\n    },\n    expandedStep: {\n      type: Number,\n      default: null\n    },\n    isReplaying: {\n      type: Boolean,\n      default: false\n    },\n    results: {\n      type: Array,\n      default: () => []\n    },\n    currentStepIndex: {\n      type: Number,\n      default: -1\n    },\n    showRuntimeProgress: {\n      type: Boolean,\n      default: true // Toujours vrai maintenant, on ignore cette prop\n    }\n  },\n  data() {\n    return {\n      localActiveTabs: {},\n      // Store active tab for each step\n      progressStatus: {} // Store runtime progress status for steps\n    };\n  },\n  computed: {\n    hasResults() {\n      return this.results && this.results.length > 0;\n    },\n    successCount() {\n      return this.results.filter(r => r.status === 'success').length;\n    },\n    errorCount() {\n      return this.results.filter(r => r.status === 'error').length;\n    },\n    skippedCount() {\n      return this.results.filter(r => r.status === 'skipped').length;\n    }\n  },\n  created() {\n    // Écouter les événements de progression en temps réel\n    window.addEventListener('step-execution-progress', this.handleStepProgress);\n    console.log('StepsList: Listening for step-execution-progress events');\n  },\n  beforeUnmount() {\n    // Nettoyer les écouteurs d'événements\n    window.removeEventListener('step-execution-progress', this.handleStepProgress);\n  },\n  methods: {\n    updateStepEnabled(index, enabled) {\n      const updatedStep = {\n        enabled,\n        skip: !enabled\n      };\n      this.$emit('update-step', index, updatedStep);\n    },\n    toggleStep(index) {\n      this.$emit('toggle-step', index);\n\n      // Initialize tab for this step if not already set\n      if (!this.localActiveTabs[index]) {\n        // Remplacer this.$set par l'affectation directe (Vue 3)\n        this.localActiveTabs = {\n          ...this.localActiveTabs,\n          [index]: 'details'\n        };\n      }\n    },\n    getMethodColor(method) {\n      const colors = {\n        GET: 'primary',\n        POST: 'success',\n        PUT: 'warning',\n        DELETE: 'error',\n        PATCH: 'info'\n      };\n      return colors[method] || 'grey';\n    },\n    hasVariables(step) {\n      return step.variableSubstitutions && step.variableSubstitutions.length > 0 || step.variableCaptures && step.variableCaptures.length > 0;\n    },\n    hasResult(index) {\n      return this.results && this.results[index];\n    },\n    getStepResultStatus(index) {\n      // Priorité au statut de progression en temps réel s'il existe\n      if (this.progressStatus[index]) {\n        return this.progressStatus[index];\n      }\n\n      // Sinon, utiliser le résultat de l'exécution finale\n      if (!this.results || this.results.length <= index) {\n        return null;\n      }\n      const result = this.results[index];\n      if (!result) return null;\n      if (result.error) return 'error';\n      return 'success';\n    },\n    hasCapturedVariables(index) {\n      return this.results && this.results[index] && this.results[index].capturedVariables && Object.keys(this.results[index].capturedVariables).length > 0;\n    },\n    hasResultError(index) {\n      return this.results && this.results[index] && this.results[index].status === 'error' && this.results[index].error;\n    },\n    getResultError(index) {\n      if (!this.hasResultError(index)) return '';\n      return this.results[index].error;\n    },\n    getStatusColor(status) {\n      if (status === 'success') return 'success';\n      if (status === 'error') return 'error';\n      if (status === 'skipped') return 'warning';\n      if (status === 'in-progress') return 'info';\n      return 'grey';\n    },\n    getStatusIcon(status) {\n      if (status === 'success') return 'mdi-check';\n      if (status === 'error') return 'mdi-close';\n      if (status === 'skipped') return 'mdi-skip-next';\n      if (status === 'in-progress') return 'mdi-loading';\n      return 'mdi-help';\n    },\n    formatRequestForDisplay(request) {\n      if (!request) return 'No request data available';\n      try {\n        // Create a simplified request object with only essential information\n        const simplifiedRequest = {\n          url: request.url || '',\n          method: request.method || '',\n          headers: request.headers || request.requestHeaders || {}\n        };\n\n        // Add query parameters\n        if (request.queryParameters) {\n          simplifiedRequest.queryParameters = request.queryParameters;\n        } else if (request.url && request.url.includes('?')) {\n          try {\n            const url = new URL(request.url);\n            const params = {};\n            url.searchParams.forEach((value, key) => {\n              params[key] = value;\n            });\n            simplifiedRequest.queryParameters = params;\n          } catch (e) {\n            console.warn('Error parsing URL query parameters:', e);\n          }\n        }\n\n        // Add body only if it exists with multiple source support\n        if (request.body || request.requestBody) {\n          try {\n            const body = request.body || request.requestBody;\n\n            // Handle string bodies (try to parse as JSON)\n            if (typeof body === 'string') {\n              try {\n                simplifiedRequest.body = JSON.parse(body);\n              } catch {\n                simplifiedRequest.body = body;\n              }\n            } else {\n              simplifiedRequest.body = body;\n            }\n          } catch (e) {\n            simplifiedRequest.body = \"Error parsing request body\";\n            console.error('Error parsing body:', e);\n          }\n        }\n        return JSON.stringify(simplifiedRequest, null, 2);\n      } catch (e) {\n        console.error('Error formatting request for display:', e);\n        return `Error formatting request: ${e.message}\\n\\nOriginal request: ${JSON.stringify(request)}`;\n      }\n    },\n    formatJson(data) {\n      if (!data) return 'No data available';\n      try {\n        if (typeof data === 'object') {\n          return JSON.stringify(data, null, 2);\n        } else if (typeof data === 'string') {\n          try {\n            const parsed = JSON.parse(data);\n            return JSON.stringify(parsed, null, 2);\n          } catch {\n            // If it's a string but not JSON, just return the string\n            return data;\n          }\n        } else {\n          return String(data);\n        }\n      } catch (e) {\n        console.error('Error formatting JSON:', e);\n        return `Error formatting data: ${e.message}`;\n      }\n    },\n    // Gestion des événements de progression en temps réel\n    handleStepProgress(event) {\n      console.log('Step progress event received:', event.detail);\n      const {\n        currentStepIndex,\n        status\n      } = event.detail;\n\n      // Mettre à jour le statut de progression pour cette étape\n      if (currentStepIndex >= 0) {\n        this.progressStatus = {\n          ...this.progressStatus,\n          [currentStepIndex]: status\n        };\n      }\n\n      // Si le statut est 'stopped' ou 'completed', on efface le statut de progression\n      if (status === 'stopped' || status === 'completed') {\n        console.log('Clearing progress status - execution completed or stopped');\n        this.progressStatus = {};\n      }\n    },\n    formatStepRequestForDisplay(step) {\n      if (!step) return 'No step data available';\n      try {\n        // Create a simplified step object with only essential information\n        const simplifiedStep = {\n          url: step.url || '',\n          method: step.method || '',\n          headers: step.headers || {}\n        };\n\n        // Add query parameters\n        if (step.queryParameters) {\n          simplifiedStep.queryParameters = step.queryParameters;\n        } else if (step.url && step.url.includes('?')) {\n          try {\n            const url = new URL(step.url);\n            const params = {};\n            url.searchParams.forEach((value, key) => {\n              params[key] = value;\n            });\n            simplifiedStep.queryParameters = params;\n          } catch (e) {\n            console.warn('Error parsing URL query parameters:', e);\n          }\n        }\n\n        // Add body from any of the possible sources where it might be stored\n        if (step.body) {\n          simplifiedStep.body = this.extractBodyContent(step.body);\n        } else if (step.requestBody) {\n          simplifiedStep.body = this.extractBodyContent(step.requestBody);\n        } else if (step._originalRequestBody) {\n          simplifiedStep.body = this.extractBodyContent(step._originalRequestBody);\n        } else if (step.request && step.request.body) {\n          simplifiedStep.body = this.extractBodyContent(step.request.body);\n        }\n        return JSON.stringify(simplifiedStep, null, 2);\n      } catch (e) {\n        console.error('Error formatting step for display:', e);\n        return `Error formatting step: ${e.message}\\n\\nOriginal step: ${JSON.stringify(step)}`;\n      }\n    },\n    extractBodyContent(body) {\n      // Handle Odoo-specific format with content wrapper\n      if (body && body.content && body.content['application/json']) {\n        return body; // Return the complete structure as is\n      }\n\n      // Handle string bodies (try to parse as JSON)\n      if (typeof body === 'string') {\n        try {\n          return JSON.parse(body);\n        } catch {\n          return body; // Return as is if not valid JSON\n        }\n      }\n\n      // Return object as is\n      return body;\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}