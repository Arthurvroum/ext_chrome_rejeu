{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { ref, computed } from 'vue';\nexport default {\n  name: 'StepDetails',\n  props: {\n    step: {\n      type: Object,\n      required: true\n    },\n    index: {\n      type: Number,\n      required: true\n    },\n    results: {\n      type: Object,\n      default: null\n    },\n    executionOptions: {\n      type: Object,\n      default: () => ({})\n    },\n    sourceOptions: {\n      type: Array,\n      default: () => [{\n        title: 'Corps de la réponse',\n        value: 'body'\n      }, {\n        title: 'En-têtes de la réponse',\n        value: 'headers'\n      }, {\n        title: 'URL de la réponse',\n        value: 'url'\n      }]\n    }\n  },\n  emits: ['update-step', 'open-capture-dialog', 'open-substitution-dialog'],\n  setup(props, {\n    emit\n  }) {\n    const activeTab = ref('details');\n    const hasResult = computed(() => !!props.results);\n    const hasCapturedVariables = computed(() => props.results && props.results.capturedVariables && Object.keys(props.results.capturedVariables).length > 0);\n\n    // Methods\n    const getResultStatus = () => {\n      if (!props.results) return null;\n      if (props.results.error) return 'error';\n      return props.results.status || 'success';\n    };\n    const getStepCaptures = () => {\n      if (!props.step.variableCaptures) {\n        // Initialize if it doesn't exist\n        emit('update-step', {\n          ...props.step,\n          variableCaptures: []\n        });\n        return [];\n      }\n      return props.step.variableCaptures;\n    };\n    const removeCapture = captureIndex => {\n      const captures = [...(props.step.variableCaptures || [])];\n      captures.splice(captureIndex, 1);\n      emit('update-step', {\n        ...props.step,\n        variableCaptures: captures\n      });\n    };\n    const getSourceLabel = source => {\n      const found = props.sourceOptions.find(opt => opt.value === source);\n      return found ? found.title : source;\n    };\n    const getStepSubstitutions = () => {\n      if (!props.step.variableSubstitutions) {\n        // Initialize if it doesn't exist\n        emit('update-step', {\n          ...props.step,\n          variableSubstitutions: []\n        });\n        return [];\n      }\n      return props.step.variableSubstitutions;\n    };\n    const removeSubstitution = subIndex => {\n      const substitutions = [...(props.step.variableSubstitutions || [])];\n      substitutions.splice(subIndex, 1);\n      emit('update-step', {\n        ...props.step,\n        variableSubstitutions: substitutions\n      });\n    };\n    const getModifiedUrl = (originalUrl, baseUrl) => {\n      if (!baseUrl || !originalUrl) {\n        return originalUrl;\n      }\n      try {\n        // Parse original URL\n        const urlObj = new URL(originalUrl);\n\n        // Parse baseUrl\n        let baseUrlObj;\n        try {\n          if (!baseUrl.startsWith('http://') && !baseUrl.startsWith('https://')) {\n            baseUrlObj = new URL('http://' + baseUrl);\n          } else {\n            baseUrlObj = new URL(baseUrl);\n          }\n        } catch (e) {\n          console.warn('Invalid baseUrl format:', baseUrl, e);\n          return originalUrl;\n        }\n\n        // Build new URL with original path and query but new origin\n        const newUrl = new URL(urlObj.pathname + urlObj.search + urlObj.hash, baseUrlObj.origin);\n        return newUrl.href;\n      } catch (e) {\n        console.warn('Error applying baseUrl:', e);\n        return originalUrl;\n      }\n    };\n    const formatRequestForDisplay = request => {\n      if (!request) return 'No request data available';\n      try {\n        // Create a simplified request object\n        const simplifiedRequest = {\n          url: request.url || '',\n          method: request.method || '',\n          headers: request.headers || request.requestHeaders || {}\n        };\n\n        // Add query parameters\n        if (request.queryParameters) {\n          simplifiedRequest.queryParameters = request.queryParameters;\n        } else if (request.url && request.url.includes('?')) {\n          try {\n            const url = new URL(request.url);\n            const params = {};\n            url.searchParams.forEach((value, key) => {\n              params[key] = value;\n            });\n            simplifiedRequest.queryParameters = params;\n          } catch (e) {\n            console.warn('Error parsing URL query parameters:', e);\n          }\n        }\n\n        // Add body only if it exists\n        if (request.body || request.requestBody) {\n          try {\n            const body = request.body || request.requestBody;\n            if (typeof body === 'string') {\n              try {\n                simplifiedRequest.body = JSON.parse(body);\n              } catch {\n                simplifiedRequest.body = body;\n              }\n            } else {\n              simplifiedRequest.body = body;\n            }\n          } catch (e) {\n            simplifiedRequest.body = \"Error parsing request body\";\n            console.error('Error parsing body:', e);\n          }\n        }\n        return JSON.stringify(simplifiedRequest, null, 2);\n      } catch (e) {\n        console.error('Error formatting request for display:', e);\n        return `Error formatting request: ${e.message}`;\n      }\n    };\n    const formatStepRequestForDisplay = step => {\n      if (!step) return 'No step data available';\n      try {\n        // Create a simplified step object\n        const simplifiedStep = {\n          url: step.url || '',\n          method: step.method || '',\n          headers: step.headers || {}\n        };\n\n        // Add query parameters\n        if (step.queryParameters) {\n          simplifiedStep.queryParameters = step.queryParameters;\n        } else if (step.url && step.url.includes('?')) {\n          try {\n            const url = new URL(step.url);\n            const params = {};\n            url.searchParams.forEach((value, key) => {\n              params[key] = value;\n            });\n            simplifiedStep.queryParameters = params;\n          } catch (e) {\n            console.warn('Error parsing URL query parameters:', e);\n          }\n        }\n\n        // Add body from possible sources\n        if (step.body) {\n          simplifiedStep.body = extractBodyContent(step.body);\n        } else if (step.requestBody) {\n          simplifiedStep.body = extractBodyContent(step.requestBody);\n        } else if (step._originalRequestBody) {\n          simplifiedStep.body = extractBodyContent(step._originalRequestBody);\n        } else if (step.request && step.request.body) {\n          simplifiedStep.body = extractBodyContent(step.request.body);\n        }\n        return JSON.stringify(simplifiedStep, null, 2);\n      } catch (e) {\n        console.error('Error formatting step for display:', e);\n        return `Error formatting step: ${e.message}`;\n      }\n    };\n    const extractBodyContent = body => {\n      // Handle Odoo-specific format with content wrapper\n      if (body && body.content && body.content['application/json']) {\n        return body; // Return the complete structure as is\n      }\n\n      // Handle string bodies\n      if (typeof body === 'string') {\n        try {\n          return JSON.parse(body);\n        } catch {\n          return body;\n        }\n      }\n      return body;\n    };\n    const formatJson = data => {\n      if (!data) return 'No data available';\n      try {\n        if (typeof data === 'object') {\n          return JSON.stringify(data, null, 2);\n        } else if (typeof data === 'string') {\n          try {\n            const parsed = JSON.parse(data);\n            return JSON.stringify(parsed, null, 2);\n          } catch {\n            return data;\n          }\n        } else {\n          return String(data);\n        }\n      } catch (e) {\n        console.error('Error formatting JSON:', e);\n        return `Error formatting data: ${e.message}`;\n      }\n    };\n    return {\n      activeTab,\n      hasResult,\n      hasCapturedVariables,\n      getResultStatus,\n      getStepCaptures,\n      removeCapture,\n      getSourceLabel,\n      getStepSubstitutions,\n      removeSubstitution,\n      getModifiedUrl,\n      formatRequestForDisplay,\n      formatStepRequestForDisplay,\n      formatJson\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}