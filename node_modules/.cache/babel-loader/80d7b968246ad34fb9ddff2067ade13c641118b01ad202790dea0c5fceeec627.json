{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nexport default {\n  name: 'StepsList',\n  props: {\n    steps: {\n      type: Array,\n      required: true\n    },\n    expandedStep: {\n      type: Number,\n      default: null\n    },\n    isReplaying: {\n      type: Boolean,\n      default: false\n    },\n    results: {\n      type: Array,\n      default: () => []\n    }\n  },\n  data() {\n    return {\n      localActiveTabs: {} // Store active tab for each step\n    };\n  },\n  computed: {\n    hasResults() {\n      return this.results && this.results.length > 0;\n    },\n    successCount() {\n      return this.results.filter(r => r.status === 'success').length;\n    },\n    errorCount() {\n      return this.results.filter(r => r.status === 'error').length;\n    },\n    skippedCount() {\n      return this.results.filter(r => r.status === 'skipped').length;\n    }\n  },\n  methods: {\n    updateStepEnabled(index, enabled) {\n      const updatedStep = {\n        enabled,\n        skip: !enabled\n      };\n      this.$emit('update-step', index, updatedStep);\n    },\n    toggleStep(index) {\n      this.$emit('toggle-step', index);\n\n      // Initialize tab for this step if not already set\n      if (!this.localActiveTabs[index]) {\n        this.$set(this.localActiveTabs, index, 'details');\n      }\n    },\n    getMethodColor(method) {\n      const colors = {\n        GET: 'primary',\n        POST: 'success',\n        PUT: 'warning',\n        DELETE: 'error',\n        PATCH: 'info'\n      };\n      return colors[method] || 'grey';\n    },\n    hasVariables(step) {\n      return step.variableSubstitutions && step.variableSubstitutions.length > 0 || step.variableCaptures && step.variableCaptures.length > 0;\n    },\n    hasResult(index) {\n      return this.results && this.results[index];\n    },\n    getStepResultStatus(index) {\n      if (!this.results || !this.results[index]) return '';\n      return this.results[index].status || '';\n    },\n    hasCapturedVariables(index) {\n      return this.results && this.results[index] && this.results[index].capturedVariables && Object.keys(this.results[index].capturedVariables).length > 0;\n    },\n    hasResultError(index) {\n      return this.results && this.results[index] && this.results[index].status === 'error' && this.results[index].error;\n    },\n    getResultError(index) {\n      if (!this.hasResultError(index)) return '';\n      return this.results[index].error;\n    },\n    getStatusColor(status) {\n      if (status === 'success') return 'success';\n      if (status === 'error') return 'error';\n      if (status === 'skipped') return 'warning';\n      if (status === 'in-progress') return 'info';\n      return 'grey';\n    },\n    getStatusIcon(status) {\n      if (status === 'success') return 'mdi-check';\n      if (status === 'error') return 'mdi-close';\n      if (status === 'skipped') return 'mdi-skip-next';\n      if (status === 'in-progress') return 'mdi-refresh';\n      return 'mdi-help';\n    },\n    formatRequestForDisplay(request) {\n      if (!request) return 'No request data available';\n      try {\n        // Create a simplified request object with only essential information\n        const simplifiedRequest = {\n          url: request.url || '',\n          method: request.method || '',\n          headers: request.headers || request.requestHeaders || {}\n        };\n\n        // Add query parameters\n        if (request.queryParameters) {\n          simplifiedRequest.queryParameters = request.queryParameters;\n        } else if (request.url && request.url.includes('?')) {\n          try {\n            const url = new URL(request.url);\n            const params = {};\n            url.searchParams.forEach((value, key) => {\n              params[key] = value;\n            });\n            simplifiedRequest.queryParameters = params;\n          } catch (e) {\n            console.warn('Error parsing URL query parameters:', e);\n          }\n        }\n\n        // Add body if it exists - better handling of different formats\n        if (request.body || request.requestBody) {\n          try {\n            const body = request.body || request.requestBody;\n            if (body === undefined || body === null) {\n              // No need to add body property\n            } else if (typeof body === 'string') {\n              // Check if it's JSON string\n              try {\n                simplifiedRequest.body = JSON.parse(body);\n              } catch (e) {\n                // If not valid JSON, keep as string\n                simplifiedRequest.body = body;\n              }\n            } else if (typeof body === 'object') {\n              // Clone object to avoid reference issues\n              simplifiedRequest.body = JSON.parse(JSON.stringify(body));\n            } else {\n              // For any other type, stringify it\n              simplifiedRequest.body = String(body);\n            }\n          } catch (e) {\n            console.error('Error processing request body:', e);\n            simplifiedRequest.body = typeof (request.body || request.requestBody) === 'string' ? request.body || request.requestBody : \"Error parsing request body\";\n          }\n        }\n        return JSON.stringify(simplifiedRequest, null, 2);\n      } catch (e) {\n        console.error('Error formatting request for display:', e);\n        return `Error formatting request: ${e.message}\\n\\nOriginal request: ${JSON.stringify(request)}`;\n      }\n    },\n    formatJson(data) {\n      if (!data) return 'No data available';\n      try {\n        if (typeof data === 'object') {\n          return JSON.stringify(data, null, 2);\n        } else if (typeof data === 'string') {\n          try {\n            const parsed = JSON.parse(data);\n            return JSON.stringify(parsed, null, 2);\n          } catch {\n            return data;\n          }\n        }\n        return String(data);\n      } catch (e) {\n        console.error('Error formatting JSON:', e);\n        return String(data);\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}